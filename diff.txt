diff --git a/.bsp/sbt.json b/.bsp/sbt.json
new file mode 100755
index 0000000..de6c9ce
--- /dev/null
+++ b/.bsp/sbt.json
@@ -0,0 +1 @@
+{"name":"sbt","version":"1.7.1","bspVersion":"2.0.0-M5","languages":["scala"],"argv":["/usr/lib/jvm/java-11-openjdk-amd64/bin/java","-Xms100m","-Xmx100m","-classpath","/home/ricardo99/.cache/sbt/boot/sbt-launch/1.8.2/sbt-launch-1.8.2.jar","-Dsbt.script=/usr/bin/sbt","xsbt.boot.Boot","-bsp"]}
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
index 0e9b59f..b27d8d0
--- a/.gitignore
+++ b/.gitignore
@@ -3,4 +3,5 @@ project/build.properties
 project/target
 project/metals.sbt
 .bloop
-.metals
\ No newline at end of file
+.metals
+.bsp
diff --git a/.travis.yml b/.travis.yml
old mode 100644
new mode 100755
index 812419d..1583b4d
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,7 @@
-language: scala
-scala:
-  - 2.13.4
-script:
-  - sbt ++$TRAVIS_SCALA_VERSION "testOnly hprog.TestShow hprog.TestP*  hprog.TestSageParser"
-notifications:
+language: scala
+scala:
+  - 2.13.4
+script:
+  - sbt ++$TRAVIS_SCALA_VERSION "testOnly hprog.TestShow hprog.TestP*  hprog.TestSageParser"
+notifications:
     slack: arcaresearch:bonMyMWOaJ6mXkB4nJD3hZdv
\ No newline at end of file
diff --git a/build.sbt b/build.sbt
index 1648b50..287443e 100755
--- a/build.sbt
+++ b/build.sbt
@@ -1,47 +1,47 @@
-name := "Hybrid Programming"
-
-version := "1.0"
-
-scalaVersion := "2.13.4" //"2.12.10" // 2.11.8  2.12.4
-
-// resolver for scala tests.
-resolvers += "Artima Maven Repository" at "https://repo.artima.com/releases"
-
-// more warnings
-scalacOptions ++= Seq("-unchecked", "-deprecation","-feature")
-
-// more complete check for complete "cases" (scala 2.10)
-// initialize ~= { _ => sys.props("scalac.patmat.analysisBudget") = "512" }
-
-libraryDependencies ++= Seq(
-
-    "junit" % "junit" % "4.12"
-  , "com.novocode" % "junit-interface" % "0.11" % "test" // to run junit tests from sbt
-
-  // , "org.choco-solver" % "choco-solver" % "4.0.6"
-  // , "org.scala-lang" % "scala-compiler" % scalaVersion.value // needed for JIT
-  , "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2" // needed for newers scala versions
-  /// new parser
-  , "org.typelevel" %% "cats-parse" % "0.3.0"
-  //
-  , "org.scalactic" %% "scalactic" % "3.2.7"
-  , "org.scalatest" %% "scalatest" % "3.2.7" % "test"
-
-  // Last stable release
-  ,"org.scalanlp" %% "breeze" % "1.1",
-  // Native libraries are not included by default. add this if you want them (as of 0.7)
-  // Native libraries greatly improve performance, but increase jar sizes.
-  // It also packages various blas implementations, which have licenses that may or may not
-  // be compatible with the Apache License. No GPL code, as best I know.
-  "org.scalanlp" %% "breeze-natives" % "1.1",
-  // The visualization library is distributed separately as well.
-  // It depends on LGPL code
-  "org.scalanlp" %% "breeze-viz" % "1.1",
-
-  // Optimus to solve quadratic programming problem
-  "com.github.vagmcs" %% "optimus" % "3.2.4",
-  "com.github.vagmcs" %% "optimus-solver-oj" % "3.2.4"
-)
-
-// tests cannot be run in parallel, because of the Choco solver
-parallelExecution in Test := false
+name := "Hybrid Programming"
+
+version := "1.0"
+
+scalaVersion := "2.13.4" //"2.12.10" // 2.11.8  2.12.4
+
+// resolver for scala tests.
+resolvers += "Artima Maven Repository" at "https://repo.artima.com/releases"
+
+// more warnings
+scalacOptions ++= Seq("-unchecked", "-deprecation","-feature")
+
+// more complete check for complete "cases" (scala 2.10)
+// initialize ~= { _ => sys.props("scalac.patmat.analysisBudget") = "512" }
+
+libraryDependencies ++= Seq(
+
+    "junit" % "junit" % "4.12"
+  , "com.novocode" % "junit-interface" % "0.11" % "test" // to run junit tests from sbt
+
+  // , "org.choco-solver" % "choco-solver" % "4.0.6"
+  // , "org.scala-lang" % "scala-compiler" % scalaVersion.value // needed for JIT
+  , "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2" // needed for newers scala versions
+  /// new parser
+  , "org.typelevel" %% "cats-parse" % "0.3.0"
+  //
+  , "org.scalactic" %% "scalactic" % "3.2.7"
+  , "org.scalatest" %% "scalatest" % "3.2.7" % "test"
+
+  // Last stable release
+  ,"org.scalanlp" %% "breeze" % "1.1",
+  // Native libraries are not included by default. add this if you want them (as of 0.7)
+  // Native libraries greatly improve performance, but increase jar sizes.
+  // It also packages various blas implementations, which have licenses that may or may not
+  // be compatible with the Apache License. No GPL code, as best I know.
+  "org.scalanlp" %% "breeze-natives" % "1.1",
+  // The visualization library is distributed separately as well.
+  // It depends on LGPL code
+  "org.scalanlp" %% "breeze-viz" % "1.1",
+
+  // Optimus to solve quadratic programming problem
+  "com.github.vagmcs" %% "optimus" % "3.2.4",
+  "com.github.vagmcs" %% "optimus-solver-oj" % "3.2.4"
+)
+
+// tests cannot be run in parallel, because of the Choco solver
+parallelExecution in Test := false
diff --git a/docs/lince.pdf b/docs/lince.pdf
old mode 100644
new mode 100755
diff --git a/lince.pdf b/lince.pdf
old mode 100644
new mode 100755
diff --git a/readme.md b/readme.md
index 4f68a40..944d28d 100755
--- a/readme.md
+++ b/readme.md
@@ -1,67 +1,67 @@
-Lince [![Build Status](https://travis-ci.org/arcalab/lince.svg?branch=master)](https://travis-ci.org/arcalab/lince)
-========================
-
-This prototype analyses hybrid programs using simulation based on symbolic evaluation (via [SageMath](http://www.sagemath.org/)) and estimation of approximation errors caused by small perturbations.
-
-You can try it online using the link below, or install it on your computer (instructions below).
-  * http://arcatools.org/#lince
-
-Lince is developed in Scala, and uses ScalaJS to generate JavaScript.
-It is developed as one of the sub-modules of ReoLive (https://github.com/ReoLanguage/ReoLive).
-
-
-Local installation of Lince
-==============
-* Requirements:
-    - SageMath (http://www.sagemath.org/)
-    - SBT (https://www.scala-sbt.org)
-    - Java runtime
-
-* Clone the [ReoLive repository](https://github.com/ReoLanguage/ReoLive) (Lince is one of its submodules)
-
-```
-git clone git@github.com:ReoLanguage/ReoLive.git
-cd ReoLive
-```
-
-* Pull the git submodules (which will include Lince):
-
-```
-git submodule update --init
-```
-
-* Use your favourite editor to edit the path to SageMath executables in:
-
-```
-global.properties
-```
-
-* Run the compilation script:
-
-```
-./compile.sh
-```
-
-* During development you can recompile faster using `sbt fastOptJS`.
-
-
-How to run the framework
-=====
-
-* Start the server using `sbt`
-
-```
-sbt server/run
-``` 
-
-*  Open `localhost:9000` in a browser
-
-```
-open http://localhost:9000#lince
-```
-
-* Alternatively, open in a browser the local html file `site/lince.html` (or `site/index.html`)
-
-```
-open file/lince.html
-```
+Lince [![Build Status](https://travis-ci.org/arcalab/lince.svg?branch=master)](https://travis-ci.org/arcalab/lince)
+========================
+
+This prototype analyses hybrid programs using simulation based on symbolic evaluation (via [SageMath](http://www.sagemath.org/)) and estimation of approximation errors caused by small perturbations.
+
+You can try it online using the link below, or install it on your computer (instructions below).
+  * http://arcatools.org/#lince
+
+Lince is developed in Scala, and uses ScalaJS to generate JavaScript.
+It is developed as one of the sub-modules of ReoLive (https://github.com/ReoLanguage/ReoLive).
+
+
+Local installation of Lince
+==============
+* Requirements:
+    - SageMath (http://www.sagemath.org/)
+    - SBT (https://www.scala-sbt.org)
+    - Java runtime
+
+* Clone the [ReoLive repository](https://github.com/ReoLanguage/ReoLive) (Lince is one of its submodules)
+
+```
+git clone git@github.com:ReoLanguage/ReoLive.git
+cd ReoLive
+```
+
+* Pull the git submodules (which will include Lince):
+
+```
+git submodule update --init
+```
+
+* Use your favourite editor to edit the path to SageMath executables in:
+
+```
+global.properties
+```
+
+* Run the compilation script:
+
+```
+./compile.sh
+```
+
+* During development you can recompile faster using `sbt fastOptJS`.
+
+
+How to run the framework
+=====
+
+* Start the server using `sbt`
+
+```
+sbt server/run
+``` 
+
+*  Open `localhost:9000` in a browser
+
+```
+open http://localhost:9000#lince
+```
+
+* Alternatively, open in a browser the local html file `site/lince.html` (or `site/index.html`)
+
+```
+open file/lince.html
+```
diff --git a/src/main/scala/hprog/.bsp/sbt.json b/src/main/scala/hprog/.bsp/sbt.json
new file mode 100755
index 0000000..023aa4a
--- /dev/null
+++ b/src/main/scala/hprog/.bsp/sbt.json
@@ -0,0 +1 @@
+{"name":"sbt","version":"1.8.2","bspVersion":"2.1.0-M1","languages":["scala"],"argv":["/usr/lib/jvm/java-11-openjdk-amd64/bin/java","-Xms100m","-Xmx100m","-classpath","/home/ricardo99/.cache/sbt/boot/sbt-launch/1.8.2/sbt-launch-1.8.2.jar","-Dsbt.script=/usr/bin/sbt","xsbt.boot.Boot","-bsp"]}
\ No newline at end of file
diff --git a/src/main/scala/hprog/DSL.scala b/src/main/scala/hprog/DSL.scala
index b794a07..8b3b66e 100755
--- a/src/main/scala/hprog/DSL.scala
+++ b/src/main/scala/hprog/DSL.scala
@@ -2,64 +2,42 @@ package hprog
 
 import hprog.ast.SymbolicExpr.SyExprAll
 import hprog.ast._
+import Syntax._
 import hprog.common.ParserException
 import hprog.frontend.CommonTypes.Valuation
 import hprog.frontend.solver.LiveSageSolver
 import hprog.frontend.{CommonTypes, Deviator, Distance, Traj}
 import hprog.lang.{Parser, Parser2, SageParser}
-
+import hprog.frontend.Utils
 import scala.language.implicitConversions
 
 /**
  * Created by jose on 17/07/18.
  */
 object DSL {
-  implicit def str2Var(s:String): Var = ast.Var(s)
+  implicit def str2VarNotLin(s:String): VarNotLin = VarNotLin(s) //new
   implicit def bool2Cond(b:Boolean): BVal = BVal(b)
-  implicit def real2Lin(n:Double): Value = Value(n)
-  implicit def int2Lin(n:Int): Value = Value(n)
-  implicit def real2Dur(n:Double): Dur = For(Value(n))
-  implicit def int2Dur(n:Int): Dur = For(Value(n))
+  implicit def real2NotLin(n:Double): ValueNotLin = ValueNotLin(n)//new
+  implicit def int2NotLin(n:Int): ValueNotLin = ValueNotLin(n)//new
+  implicit def real2Dur(n:Double): Dur = For(ValueNotLin(n))
+  implicit def int2Dur(n:Int): Dur = For(ValueNotLin(n))
   implicit def cond2Dur(c:Cond): Dur = Until(c,None,None)
   implicit def dEq2dEqs(de:DiffEq): DiffEqs= DiffEqs(List(de),Forever)
-  implicit def assg2Atom(a:Assign): Atomic = Atomic(List(a),DiffEqs(Nil,For(Value(0))))
+  implicit def assg2Atom(a:Assign): Atomic = Atomic(List(a),DiffEqs(Nil,For(ValueNotLin(0))))
   implicit def dEqs2Atom(des:DiffEqs): Atomic = Atomic(Nil,des)
+ 
 
-
-  val x:Var="x"; val y:Var="y"; val p:Var="p"; val v:Var="v"; val g:Var="g"
-
-  // examples
-  val ex1 = Assign(x,Value(2))            // assignment
-  val ex2 = (y^=3) & 34     // statement
-  val ex3 = (x^=2) & (y^=3) // statement
-  //val ex4 = (x^=2) ~ (y^=3) // program
-  val ex5 = (y:=0) ~ (x:=0) ~ ((x^=2) & (y^=3) & 34) ~ ((x^=2) & (x > 2)) // program
-  val ex6 = (x:=0) ~ ((x^=1) & ((x > 3*x) && (x<5)))
-  val ex7 = ((p^=v) & (v^=g) & ((p<=0) && (v<=0))) ~ (v := (-0.5)*v) // bouncing ball
-  val ex8 = (x^=1) & (((x > 3*x) && (x<5)) || (y>=3))
-  val ex9 = (x^=1) & ((x > 3*x) && ((x<5) || (y>=3)))
-
+ 
   /**
     * Parses a string into a program.
     * @param s string representing a program
     * @return parsed program
     */
   def parse(s:String): Syntax =  {
-    //println("parsing...")
-//    Parser2.parse(s) match {
-//      case Right(result) =>
-//        //println("parsed")
-//        result
-//      case Left(f) =>
-//        //println("failed")
-//        throw new ParserException(f.toString)
-//    }
     Parser.parse(s) match {
       case Parser.Success(result, _) =>
-        //println("parsed")
         result
       case f: Parser.NoSuccess =>
-        //println("failed")
         throw new ParserException(f.toString)
     }
   }
@@ -70,13 +48,10 @@ object DSL {
     * @return parsed expression
     */
   def parseExpr(s:String): SyExprAll =  {
-    //println("parsing...")
     SageParser.parseExpr(s) match {
       case SageParser.Success(result, _) =>
-        //println("parsed")
         result
       case f: SageParser.NoSuccess =>
-        //println("failed")
         throw new ParserException(f.toString)
     }
   }
@@ -87,21 +62,14 @@ object DSL {
     * @return parsed expression
     */
   def parseCond(s:String): Cond =  {
-    //println("parsing...")
     Parser2.parseCond(s) match {
       case Right(result) => //Parser.Success(result, _) =>
-        //println("parsed")
         result
       case Left(f) => //: Parser.NoSuccess =>
-        //println("failed")
         throw new ParserException(f.toString)
     }
   }
 
-//  val parseWithError: String => Parser.ParseResult[Syntax] = Parser.parse
   val parseWithError: String => Either[String,Syntax] = Parser2.parse
 
-  //  def parseTraj(s:String,sagePath:String): Traj[Valuation] = // e.g., sagePath = "/home/jose/Applications/SageMath"
-//    Semantics.syntaxToValuation(parse(s),new LiveSageSolver(sagePath), new Distance(10)).traj(Map())
-
 }
diff --git a/src/main/scala/hprog/ast/.bsp/sbt.json b/src/main/scala/hprog/ast/.bsp/sbt.json
new file mode 100644
index 0000000..023aa4a
--- /dev/null
+++ b/src/main/scala/hprog/ast/.bsp/sbt.json
@@ -0,0 +1 @@
+{"name":"sbt","version":"1.8.2","bspVersion":"2.1.0-M1","languages":["scala"],"argv":["/usr/lib/jvm/java-11-openjdk-amd64/bin/java","-Xms100m","-Xmx100m","-classpath","/home/ricardo99/.cache/sbt/boot/sbt-launch/1.8.2/sbt-launch-1.8.2.jar","-Dsbt.script=/usr/bin/sbt","xsbt.boot.Boot","-bsp"]}
\ No newline at end of file
diff --git a/src/main/scala/hprog/ast/SymbolicExpr.scala b/src/main/scala/hprog/ast/SymbolicExpr.scala
old mode 100644
new mode 100755
index 2eeea4b..8c4a904
--- a/src/main/scala/hprog/ast/SymbolicExpr.scala
+++ b/src/main/scala/hprog/ast/SymbolicExpr.scala
@@ -17,13 +17,12 @@ object SymbolicExpr {
 
 sealed trait SymbolicExpr[+X<:SymbolicExpr.All] {
   override def toString: String = this match {
-//    case SVal(v) if (v-v.round)==0 => v.toInt.toString
-//    case SVal(v) => v.toString
     case s:SVal => Show.floatToFraction(s.v)
     case _:SArg => "t"
     case s:SVar => s.v
     case SFun(f, args) => s"$f(${args.mkString(",")})"
     case SDiv(e1, e2) => s"$e1/$e2"
+    case SRes(e1,e2) => s"$e1%$e2"
     case SMult(e1, e2) => s"$e1*$e2"
     case SPow(e1, e2) => s"$e1^$e2"
     case SAdd(e1, e2) => s"$e1+$e2"
@@ -35,12 +34,6 @@ sealed trait SymbolicExpr[+X<:SymbolicExpr.All] {
   def *(that: SyExprAll): SyExprAll = SMult(this,that)
   def /(that: SyExprAll): SyExprAll = SDiv(this,that)
   def ^(that: SyExprAll): SyExprAll = SPow(this,that)
-
-  //  def -[X2<:X](that: SageExpr[X2]): SageExpr[X] = SSub(this,that)
-//  def *[X2<:X](that: SageExpr[X2]): SageExpr[X] = SMult(this,that)
-//  def /[X2<:X](that: SageExpr[X2]): SageExpr[X] = SDiv(this,that)
-//  def ^[X2<:X](that: SageExpr[X2]): SageExpr[X] = SPow(this,that)
-
 }
 
 case class SVal(v:Double)                     extends SymbolicExpr[Pure]
@@ -49,6 +42,7 @@ case class SVar(v:String)                     extends SymbolicExpr[Vars]
 case class SFun[X<:All](f:String, args:List[SymbolicExpr[X]])
                                               extends SymbolicExpr[X]
 case class SDiv[X<:All](e1:SymbolicExpr[X], e2:SymbolicExpr[X])  extends SymbolicExpr[X]
+case class SRes[X<:All](e1:SymbolicExpr[X], e2:SymbolicExpr[X])  extends SymbolicExpr[X]
 case class SMult[X<:All](e1:SymbolicExpr[X], e2:SymbolicExpr[X]) extends SymbolicExpr[X]
 case class SPow[X<:All](e1:SymbolicExpr[X], e2:SymbolicExpr[X])  extends SymbolicExpr[X]
 case class SAdd[X<:All](e1:SymbolicExpr[X], e2:SymbolicExpr[X])  extends SymbolicExpr[X]
diff --git a/src/main/scala/hprog/ast/Syntax.scala b/src/main/scala/hprog/ast/Syntax.scala
index 4259e9e..ba9679d 100755
--- a/src/main/scala/hprog/ast/Syntax.scala
+++ b/src/main/scala/hprog/ast/Syntax.scala
@@ -1,248 +1,149 @@
-package hprog.ast
-
-/**
-A element `p` of the class `Syntax` is our internal representation of a Lince program `p`.
-
-Overview of the grammar:
-```
- p := at | p;p | Skip | if b then p else p | While b p | ... Wait r
- at := assgn | diffEq
- assgn := X := lin
- diffEq := (X' = lin)* ("" | "&" lin | "&" b)
- lin := X | R | lin+lin | R lin
-
- b?  := true | false | &|! | X {><=} lin
-```
-
-Examples of programs include:
-```
- x:=0 ;
- x'=y+2x, y'=3 & 1 ;
- x'=2 & 2
-
- p'=v, v'=g & p<=0 /\ v<=0 ;
- v:= -0.5*v
-```
-  */
-
-sealed abstract class Syntax {
-  /** Sequential composition of programs with some pre-processing */
-  def ~(other:Syntax): Syntax = other match {
-    case While(pre,d,doP) => While(this~pre,d,doP)
-    case _ => Seq(this,other)
-  }
-//  def ~(other:Syntax): Syntax = Seq(this,other)
-//  def ~(other:Syntax) = (this,other) match {
-//    case (Seq(p1), Seq(p2)) => Seq(p1 ::: p2)
-//    case (Seq(p1), p2) => Seq(p1 ::: List(p2))
-//    case (p1, Seq(p2)) => Seq(p1 :: p2)
-//    case (p1, p2) => Seq(List(p1, p2))
-//  }
-}
-/** An atomic program is a list of assignments and a system of differential equations with a bound */
-case class Atomic(as:List[Assign],de:DiffEqs)        extends Syntax {
-  /** Sequential composition of programs with some pre-processing */
-  override def ~(p:Syntax): Syntax = (de.dur,p) match {
-    case (_,Seq(p,q)) => Seq(this~p,q)
-    case (_,While(pre, d, doP)) => While(this~pre,d,doP)
-    case (For(Value(0)),Atomic(as2,de)) => Atomic(as++as2,de)
-    case (_,_) => Seq(this,p)
-  }
-//  def ~(a:Assign): Syntax = this ~ Atomic(List(a),DiffEqs(Nil,For(Value(0))))
-//  def ~(de:DiffEq): Syntax = this ~ Atomic(Nil,DiffEqs(List(de),Forever))
-}
-/** Sequence of programs is a program*/
-case class Seq(p:Syntax,q:Syntax)                    extends Syntax
-/**  "If-then-else" is a program*/
-case class ITE(ifP:Cond, thenP:Syntax, elseP:Syntax) extends Syntax
-/** "While" is a program */
-case class While(pre:Syntax,d:LoopGuard,doP:Syntax)  extends Syntax
-
-//case object           Skip                                      extends Syntax
-//case class            SPosition(s1:Syntax,s2:Syntax)            extends Syntax
-
-/** An assignment is a member of the Atomic programs, between a variable and a linear expression */
-case class Assign(v:Var,e:Lin) {
-//  def ~(p:Syntax): Syntax = Atomic(List(this),DiffEqs(Nil,For(Value(0)))) ~ p
-//  def ~(a:Assign): Syntax = A
-}
-case class DiffEqs(eqs:List[DiffEq],dur:Dur) {
-  def &(dur:Dur): DiffEqs = DiffEqs(eqs,dur) // override dur
-  def &(diffEq: DiffEq): DiffEqs = DiffEqs(eqs++List(diffEq),dur) // add eq
-  def &(diffEqs: DiffEqs): DiffEqs = DiffEqs(eqs++diffEqs.eqs,diffEqs.dur) // add eqs and override dur
-}
-
-// DiffEq
-case class DiffEq(v:Var,e:Lin)
-
-// duration
-sealed abstract class Dur
-case class  For(e:Lin)  extends Dur
-case class  Until(c:Cond, eps:Option[Double], jump:Option[Double]) extends Dur
-case object Forever       extends Dur
-
-// loopguard
-sealed abstract  class LoopGuard
-case class Counter(i:Int) extends LoopGuard
-case class Guard(c:Cond)  extends LoopGuard
-
-// linear expression
-sealed abstract class Lin {
-  def +(other:Lin): Lin = Add(this,other)
-}
-case class Var(v:String)       extends Lin {
-  def :=(l: Lin): Assign = Assign(this,l)
-  def ^=(l: Lin): DiffEq = DiffEq(this,l)
-  def >(l: Lin):  Cond = GT(this,l)
-  def <(l: Lin):  Cond = LT(this,l)
-  def >=(l: Lin): Cond = GE(this,l)
-  def <=(l: Lin): Cond = LE(this,l)
-  def ===(l: Lin):Cond = EQ(this,l)
-}
-case class Value(v:Double)     extends Lin {
-  def *(l: Lin): Lin = Mult(this,l)
-}
-case class Add(l1:Lin,l2:Lin)  extends Lin
-case class Mult(v:Value,l:Lin) extends Lin
-
-// Conditions
-sealed abstract class Cond {
-  def &&(that:Cond): Cond  = (this,that) match {
-    case (BVal(true),_) => that
-    case (_,BVal(true)) => this
-    case (BVal(false),_) => BVal(false)
-    case (_,BVal(false)) => BVal(false)
-    case _ => if (this==that) this else And(this,that)
-  }
-  def ||(that:Cond): Cond  = (this,that) match {
-    case (BVal(true),_) => BVal(true)
-    case (_,BVal(true)) => BVal(true)
-    case (BVal(false),_) => that
-    case (_,BVal(false)) => this
-    case _ => if (this==that) this else Or(this,that)
-  }
-  def <=>(that:Cond): Cond =
-    (this && that) || (Not(this) && Not(that))
-  def -->(that:Cond): Cond = that || Not(this)
-}
-case class BVal(b:Boolean)      extends Cond
-case class And(c1:Cond,c2:Cond) extends Cond
-case class Or(c1:Cond,c2:Cond)  extends Cond
-case class Not(c:Cond)          extends Cond
-case class EQ(l1:Lin,l2:Lin)    extends Cond
-case class GT(l1:Lin,l2:Lin)    extends Cond
-case class LT(l1:Lin,l2:Lin)    extends Cond
-case class GE(l1:Lin,l2:Lin)    extends Cond
-case class LE(l1:Lin,l2:Lin)    extends Cond
-//case class EQ(v:Var,l:Lin)      extends Cond
-//case class GT(v:Var,l:Lin)      extends Cond
-//case class LT(v:Var,l:Lin)      extends Cond
-//case class GE(v:Var,l:Lin)      extends Cond
-//case class LE(v:Var,l:Lin)      extends Cond
-
-
-
-// boolean expression
-//sealed abstract class BExpr extends Cond
-//case class Not(c:Cond)      extends Cond
-
-
-/*
-Ideas for later - obtaining a trajectory:
- - for each basic program (not a sequence)
- - if a new variable is found, assume it was initially 0
- - assignments update the variable
- - keep map of known variables (unknown are 0)
- - mark undefined variables (assumed to be 0)
- - calculate duration of next action
-    + could be 0 for assignments
-    + could be +inf for "forever"
-    + could be a time value
-    + could be a condition -- need to solve system?
- - compute function until next action...
- - iterate
- */
-
-
-//sealed abstract class Progr {
-//  def ~(other:Progr) = (this,other) match {
-//    case (Seq(p1),Seq(p2)) => Seq(p1:::p2)
-//    case (Seq(p1),p2) => Seq(p1:::List(p2))
-//    case (p1,Seq(p2)) => Seq(p1::p2)
-//    case (p1,p2) => Seq(List(p1,p2))
-//  }
-//
-//  override def toString: String = Show(this)
-////  def show = Show(this)
-//}
-//
-////sealed trait Atom extends Progr
-//case class Seq(ps:List[Progr])                        extends Progr
-//case class Statement(st:List[Assgn],dur:Option[Expr]) extends Progr {
-//  def &(e:Expr) = Statement(this.st,Some(e))
-//  def &(a:Assgn) = Statement(this.st:::List(a),this.dur)
-//}
-//case class Assgn(v:Var,e:Expr) {
-//  def &(e2:Expr) = Statement(List(this),Some(e2))
-//  def &(a:Assgn) = Statement(List(this,a),None)
-//  override def toString: String =  Show(this)
-//}
-//
-//
-///**
-// * Integer expressions
-// */
-//sealed trait Expr {
-//  // helpers to DSL
-//  def +(that:Expr) = Add(this,that)
-//  def -(that:Expr) = Sub(this,that)
-//  def *(that:Expr) = Mul(this,that)
-//  def /(that:Expr) = Div(this,that)
-//  def ===(that:Expr) = EQ(this,that)
-//  def >(that:Expr)   = GT(this,that)
-//  def <(that:Expr)   = LT(this,that)
-//  def >=(that:Expr)  = GE(this,that)
-//  def <=(that:Expr)  = LE(this,that)
-//  // Booleans
-//  def &&(that:Expr) = (this,that) match {
-//    case (BVal(true),_) => that
-//    case(_,BVal(true)) => this
-//    case (And(e1),And(e2)) => And(e1:::e2)
-//    case (And(es),_) => if (es contains that) this else And(es:::List(that)) // naive avoidance of repetitions
-//    case (_,And(es)) => if (es contains this) that else And(this::es)        // naive avoidance of repetitions
-//    case _ => And(List(this,that))
-//  }
-//  def <=>(that:Expr) =
-//    (this && that) || (Not(this) && Not(that))
-//  def ||(that:Expr) = Or(this,that)
-//
-//  override def toString: String =  Show(this)
-//}
-//
-//case class Var(name:String,der:Int) extends Expr {
-//  def :=(e:Expr): Assgn = Assgn(this,e)
-//  def ! : Var = Var(name,der+1)
-////  def unary_! : Var = Var(name,der+1)
-//}
-//case class Val(v:Double) extends Expr
-//case class Add(e1:Expr,e2:Expr) extends Expr
-//case class Sub(e1:Expr,e2:Expr) extends Expr
-//case class Mul(e1:Expr,e2:Expr) extends Expr
-//case class Div(e1:Expr,e2:Expr) extends Expr
-//// case class Sum(x:Var,from:Expr,to:Expr,e:Expr) extends Expr
-//// case class ITE(b:BExpr,ifTrue:Expr,ifFalse:Expr) extends Expr
-//
-//
-//// Booleans
-//case class BVal(b:Boolean) extends Expr
-//case class And(es:List[Expr])  extends Expr // special treatment for ands, because constraints in typechecking are a big conjunction
-//case class Or(e1:Expr,e2:Expr) extends Expr
-//case class Not(e:Expr)         extends Expr
-//case class EQ(e1:Expr,e2:Expr) extends Expr
-//case class GT(e1:Expr,e2:Expr) extends Expr
-//case class LT(e1:Expr,e2:Expr) extends Expr
-//case class LE(e1:Expr,e2:Expr) extends Expr
-//case class GE(e1:Expr,e2:Expr) extends Expr
-//// case class AndN(x:Var,from:Expr,to:Expr,e:Expr) extends Expr // to is "excluding"
-
-
+package hprog.ast
+import Syntax._
+/**
+A element `p` of the class `Syntax` is our internal representation of a Lince program `p`.
+
+Overview of the grammar:
+```
+ p := at | at;q
+ q:= at | q;q | Skip | if b then q else q | While b do {q} | ... Wait r
+ at := assgn | diffEq
+ assgn := X := NotLin
+ diffEq := (X' = lin) | (X' = lin), For X | (X' = lin), Until args b
+ lin := X | R | lin+lin | R*lin | lin*R | X/R
+
+ b?  := true | false | && | ! | || | NotLin {><=} NotLin
+```
+  */
+object Syntax {
+  
+  sealed abstract class Syntax {
+    /** Sequential composition of programs with some pre-processing */
+    def ~(other:Syntax): Syntax = other match {
+      //case While(pre,d,doP) => While(this~pre,d,doP)
+      case _ => Seq(this,other)
+    }
+  }
+
+
+  /** An atomic program is a list of assignments and a system of differential equations with a bound */
+  case class Atomic(as:List[Assign],de:DiffEqs)        extends Syntax {
+    /** Sequential composition of programs with some pre-processing */
+    override def ~(p:Syntax): Syntax = (de.dur,p) match {
+      case (_,Seq(p,q)) => Seq(this~p,q)
+      case (_,While(pre, d, doP)) => While(this~pre,d,doP)
+      case (_,_) => Seq(this,p)
+    }
+  }
+
+  /** Sequence of programs is a program*/
+  case class Seq(p:Syntax,q:Syntax)                    extends Syntax
+  /**  "If-then-else" is a program*/
+  case class ITE(ifP:Cond, thenP:Syntax, elseP:Syntax) extends Syntax
+  /** "While" is a program */
+  case class While(pre:Syntax,d:LoopGuard,doP:Syntax)  extends Syntax
+
+  
+  /** An assignment is a member of the Atomic programs, between a variable and a non linear expression */
+  case class Assign(v:VarNotLin,e:NotLin) 
+
+  case class DiffEqs(eqs:List[DiffEq],dur:Dur) {
+    def &(dur:Dur): DiffEqs = DiffEqs(eqs,dur) // override dur
+    def &(diffEq: DiffEq): DiffEqs = DiffEqs(eqs++List(diffEq),dur) // add eq
+    def &(diffEqs: DiffEqs): DiffEqs = DiffEqs(eqs++diffEqs.eqs,diffEqs.dur) // add eqs and override dur
+  }
+
+  // DiffEq
+  case class DiffEq(v:VarNotLin,e:NotLin)
+
+  // duration
+  sealed abstract class Dur
+  case class  For(e:NotLin)  extends Dur
+  case class  Until(c:Cond, eps:Option[Double], jump:Option[Double]) extends Dur
+  case object Forever       extends Dur
+
+  // loopguard
+  sealed abstract  class LoopGuard
+  case class Counter(i:Int) extends LoopGuard
+  case class Guard(c:Cond)  extends LoopGuard
+
+  // non linear expression
+  sealed abstract class NotLin {
+    def +(other:NotLin): NotLin = AddNotLin(this,other)
+  }
+  case class VarNotLin(v:String)       extends NotLin {
+    def ^=(l: NotLin): DiffEq = DiffEq(this,l) //New
+    def :=(l: NotLin): Assign = Assign(this,l)
+    def >(l: NotLin):  Cond = GT(this,l)
+    def <(l: NotLin):  Cond = LT(this,l)
+    def >=(l: NotLin): Cond = GE(this,l)
+    def <=(l: NotLin): Cond = LE(this,l)
+    def ===(l: NotLin):Cond = EQ(this,l)
+  }
+  case class ValueNotLin(v:Double)     extends NotLin { 
+    def *(l: NotLin): NotLin = MultNotLin(this,l) 
+  }
+  case class AddNotLin(l1:NotLin,l2:NotLin)  extends NotLin 
+
+  case class MultNotLin(l1:NotLin,l2:NotLin) extends NotLin 
+  
+  case class DivNotLin(l1:NotLin,l2:NotLin) extends NotLin 
+
+  case class ResNotLin(l1:NotLin,l2:NotLin) extends NotLin 
+
+  case class FuncNotLin(s:String, arg:List[NotLin]) extends NotLin
+
+  case class PowNotLin(l1:NotLin,l2:NotLin) extends NotLin 
+
+
+/*
+  // linear expression
+  sealed abstract class Lin {
+    def +(other:Lin): Lin = Add(this,other)
+  }
+  case class Var(v:String)       extends Lin {
+    def ^=(l: Lin): DiffEq = DiffEq(this,l)
+  }
+  case class Value(v:Double)     extends Lin {
+    def *(l: Lin): Lin = Mult(this,l)
+  }
+  case class Add(l1:Lin,l2:Lin)  extends Lin
+
+  case class Mult(l1:Lin,l2:Lin) extends Lin
+
+*/
+
+  // Conditions
+  sealed abstract class Cond {
+    def &&(that:Cond): Cond  = (this,that) match {
+      case (BVal(true),_) => that
+      case (_,BVal(true)) => this
+      case (BVal(false),_) => BVal(false)
+      case (_,BVal(false)) => BVal(false)
+      case _ => if (this==that) this else And(this,that)
+    }
+    def ||(that:Cond): Cond  = (this,that) match {
+      case (BVal(true),_) => BVal(true)
+      case (_,BVal(true)) => BVal(true)
+      case (BVal(false),_) => that
+      case (_,BVal(false)) => this
+      case _ => if (this==that) this else Or(this,that)
+    }
+    def <=>(that:Cond): Cond =
+      (this && that) || (Not(this) && Not(that))
+    def -->(that:Cond): Cond = that || Not(this)
+  }
+  case class BVal(b:Boolean)      extends Cond
+  case class And(c1:Cond,c2:Cond) extends Cond
+  case class Or(c1:Cond,c2:Cond)  extends Cond
+  case class Not(c:Cond)          extends Cond
+  case class EQ(l1:NotLin,l2:NotLin)    extends Cond
+  case class GT(l1:NotLin,l2:NotLin)    extends Cond
+  case class LT(l1:NotLin,l2:NotLin)    extends Cond
+  case class GE(l1:NotLin,l2:NotLin)    extends Cond
+  case class LE(l1:NotLin,l2:NotLin)    extends Cond
+  
+
+
+
+}
diff --git a/src/main/scala/hprog/backend/Show.scala b/src/main/scala/hprog/backend/Show.scala
index fa36dc7..24ea93f 100755
--- a/src/main/scala/hprog/backend/Show.scala
+++ b/src/main/scala/hprog/backend/Show.scala
@@ -2,100 +2,226 @@ package hprog.backend
 
 import hprog.ast.SymbolicExpr.{Pure, SyExpr}
 import hprog.ast._
+import Syntax._
 import hprog.frontend.CommonTypes.{SySolution, Valuation}
 import hprog.frontend.{Eval, Traj}
 import hprog.frontend.Traj.RunTarget
 
+
+/*
+Método map():
+collection = (e1, e2, e3, ...)
+
+func is some function collection.map(func)
+
+returns collection(func(e1), func(e2), func(e3), ...)
+
+*/
+
+
+
+/*
+Método mkString():
+Method Definition: def mkString(sep: String): String
+
+Return Type: It returns all the elements of the list in a string along with a separator.
+*/
+
+
 object Show {
 
-//  def apply(p:Syntax): String = p match {
-//    case a: At    => apply(a)
-////    case Seq(p::Nil) => apply(p)
-//    case Seq(ps) => ps.map(apply).mkString("\n")
-//    case Skip    => "skip"
-//    case ITE(ifP, thenP, elseP) => s"if ${apply(ifP)} then ${apply(thenP)} else ${apply(elseP)} "
-//    case While(Guard(c), doP)   => s"while (${apply(c)}) { ${apply(doP)} }"
-//    case While(Counter(i), doP) => s"while ($i) { ${apply(doP)} }"
-//  }
-
-//  def apply(a:At): String = a match {
-//    case Assign(v, e) => s"${v.v} := ${apply(e)}"
-//    case DiffEqs(eqs, dur) => apply(eqs)+apply(dur)
-//  }
 
   def apply(p:Syntax): String = p match {
-    case Atomic(as, de) =>
-      val assg = as.map(a => s"${a.v.v}:=${apply(a.e)}")
-      val eqs = de.eqs.map(apply)
-      (assg++eqs).mkString(", ")+apply(de.dur)
-//        (apply(de.eqs)+apply(de.dur)).filter(_.nonEmpty)).mkString(", ")
+    case Atomic(as, de) => // If it is an atomic
+      val assg = as.map(a => s"${a.v.v}:=${apply(a.e)}") // I store the assigments here, in string form, like: " v:= 37", at the end it returns a list of these
+      val eqs = de.eqs.map(apply) // I store differential equations also in string form, like: "v'= v+2", at the end it returns a list of this
+      aux_gramatic(assg.mkString(";"),eqs.mkString(","),apply(de.dur))++";"// I concatenate the lists of assg and eqs, apply mkString to separate the assigments by commas and the diff eqs, and at the end I paste the duration, returning a string from all this
+
     case Seq(p, q) => List(apply(p),apply(q)).filter(_.nonEmpty).mkString("\n")
-    case ITE(ifP, thenP, elseP) =>  s"if ${apply(ifP)} then ${apply(thenP)} else ${apply(elseP)} "
-    case While(pre, Guard(c), doP) => apply(pre) + s"while (${apply(c)}) { ${apply(doP)} }"
-    case While(pre, Counter(i), doP) => apply(pre) + s"while ($i) { ${apply(doP)} }"
+    case ITE(ifP, thenP, elseP) =>  s"if ${apply(ifP)} then {${apply(thenP)}} else {${apply(elseP)}} "
+    case While(pre, Guard(c), doP) => apply(pre) + "\n" + s"while ${apply(c)} do { ${apply(doP)} }"
+    case While(pre, Counter(i), doP) => apply(pre) + "\n" +  s"while $i do { ${apply(doP)} }"
   }
 
 
   def apply(eqs:List[DiffEq]): String =
-    eqs.map(apply).mkString(", ")
+    eqs.map(apply).mkString(",")
+  
+// put the ";" in the right places
+  def aux_gramatic(ass:String,diff:String,dur:String):String={
+    if (ass.length==0){
+      return (diff + dur)
+    } else {
+      if ((diff.length!=0) || (dur.length!=0)){
+        return (ass+";"+diff+dur)
+      } else {
+        return ass
+      }
+    }
+  }  
+ 
 
   def apply(de: DiffEq): String = de match {
     case DiffEq(v, e) => s"${v.v}'=${apply(e)}"
   }
 
   def apply(dur: Dur): String = dur match {
-    //case For(Value(0.0)) => ""
-    case For(t)  => s" for ${apply(t)}"
+    case For(t)  => s" for ${apply(t)}" // return the string " for" ++ string of linear expression
     case Until(c,e,j) => s" until_$e${
-      if(j.isDefined)","+j.get else ""} ${apply(c)}"
+      if(j.isDefined)","+j.get else ""} ${apply(c)}"  // return the string "until_" ++ string esp ++ space ++ string of the condictions
     case Forever => " forever"
   }
 
+
+/*
   def apply(lin: Lin): String = apply(lin,Map():Valuation)
 
   def apply(lin: Lin, vl: Valuation): String = lin match {
     case v:Var => showVar(v,vl,apply[Pure])
     case Value(v) => floatToFraction(v)//if (v-v.toInt == 0) v.toInt.toString else v.toString
     case Add(l1, l2)    => s"${apply(l1,vl)} + ${apply(l2,vl)}"
-    case Mult(v, l:Add) => s"${apply(v,vl)}*(${apply(l,vl)})"
-    case Mult(v, l)     => s"${apply(v,vl)}*${apply(l,vl)}"
+    //case Mult(l1, l2:Add) => s"${apply(l1,vl)}*(${apply(l2,vl)})"
+    case Mult(l1, l2)     => s"${applyMP(l1,vl)}*${applyMP(l2,vl)}"
+  }
+
+  def applyMP(lin: Lin, vl: Valuation): String = lin match {
+    case Add(_,_) => s"(${apply(lin,vl)})"
+    case _ => apply(lin,vl)
+  }
+*/
+  
+  def apply(notlin:NotLin): String= apply(notlin,Map():Valuation)
+
+
+/*
+  def apply(notlin: NotLin, vl: Valuation): String = notlin match {
+    case v:VarNotLin => showVarNotLin(v,vl,apply[Pure])
+    // If Value is an integer it will print without the zero, otherwise it prints with decimals 
+    case ValueNotLin(v) => floatToFraction(v)//if (v-v.toInt == 0) v.toInt.toString else v.toString
+    
+ //new
+    case AddNotLin(l1, l2)    => s"(${apply(l1,vl)} + ${apply(l2,vl)})"
+    case MultNotLin(l1:AddNotLin, l2:AddNotLin) => s"(${apply(l1,vl)})*(${apply(l2,vl)})" 
+    case MultNotLin(l1, l2:AddNotLin) => s"(${apply(l1,vl)})*(${apply(l2,vl)})"
+    case MultNotLin(l1:AddNotLin, l2) => s"(${apply(l1,vl)})*(${apply(l2,vl)})"
+    case MultNotLin(l1, l2) => s"(${apply(l1,vl)})*(${apply(l2,vl)})"
+    // MultNotLin(l1,l2)=> s"${applyp(l1,cl)}*{applyp(l2,vl)}
+    
+    case DivNotLin(l1:AddNotLin, l2:AddNotLin) => s"(${apply(l1,vl)})/(${apply(l2,vl)})" 
+    case DivNotLin(l1, l2:AddNotLin) => s"(${apply(l1,vl)})/(${apply(l2,vl)})"
+    case DivNotLin(l1:AddNotLin, l2) => s"(${apply(l1,vl)})/(${apply(l2,vl)})"
+    case DivNotLin(l1, l2) => s"(${apply(l1,vl)})/(${apply(l2,vl)})"
+    
+
+    case ResNotLin(l1:AddNotLin, l2:AddNotLin) => s"(${apply(l1,vl)})%(${apply(l2,vl)})" 
+    case ResNotLin(l1, l2:AddNotLin) => s"(${apply(l1,vl)})%(${apply(l2,vl)})"
+    case ResNotLin(l1:AddNotLin, l2) => s"(${apply(l1,vl)})%(${apply(l2,vl)})"
+    case ResNotLin(l1, l2) => s"(${apply(l1,vl)})%(${apply(l2,vl)})"
+
+
+    case PowNotLin(l1,l2)=> s"pow(${apply(l1,vl)},${apply(l2,vl)})"
+    case FuncNotLin("PI",Nil)=>s"pi"
+    case FuncNotLin("E",Nil)=>s"e"
+    case FuncNotLin("log10",list)=> s"log(${stringList(list)})/log(10)"
+    case FuncNotLin(s,list)=>s"${s}(${stringList(list)})"
+
+  }
+*/
+
+
+
+def apply(notlin: NotLin, vl: Valuation): String = notlin match {
+    case v:VarNotLin => showVarNotLin(v,vl,apply[Pure])
+    // If Value is an integer it will print without the zero, otherwise it prints with decimals 
+    case ValueNotLin(v) => floatToFraction(v)//if (v-v.toInt == 0) v.toInt.toString else v.toString
+    
+ //new
+    case AddNotLin(l1, l2)    => s"${apply_paranteses(l1,vl)} + ${apply_paranteses(l2,vl)}"
+
+    case MultNotLin(l1, l2) => s"${apply_paranteses(l1,vl)}*${apply_paranteses(l2,vl)}"
+
+    case DivNotLin(l1, l2) => s"${apply_paranteses(l1,vl)}/(${apply_paranteses(l2,vl)})"
+    
+    case ResNotLin(l1, l2) => s"${apply_paranteses(l1,vl)}%(${apply_paranteses(l2,vl)})"
+
+    case PowNotLin(l1,l2)=> s"pow(${apply_paranteses(l1,vl)},${apply_paranteses(l2,vl)})"
+    
+    case FuncNotLin("PI",Nil)=>s"pi"
+    case FuncNotLin("E",Nil)=>s"e"
+    case FuncNotLin("log10",list)=> s"log(${stringList(list)})/log(10)"
+    case FuncNotLin(s,list)=>s"${s}(${stringList(list)})"
+
+  }
+
+  def apply_paranteses(notlin:NotLin,vl:Valuation):String= notlin match {
+    case v:VarNotLin => showVarNotLin(v,vl,apply[Pure])
+    case ValueNotLin(v) => floatToFraction(v)
+    case FuncNotLin("PI",Nil)=>s"pi"
+    case FuncNotLin("E",Nil)=>s"e"
+    case FuncNotLin("log10",list)=> s"log(${stringList(list)})/log(10)"
+    case FuncNotLin(s,list)=>s"${s}(${stringList(list)})"
+    case _ => s"(${apply(notlin,vl)})"
+  }
+
+def stringList(list:List[NotLin]): String = list match{
+    case List() => s""
+    case n::List() => s"${apply(n)}"
+    case n::ns => s"${apply(n)},${stringList(ns)}"
   }
 
   // show a condition parseable by Sage
   def apply(cond: Cond, vl:Valuation = Map()): String = cond match {
     case BVal(b)     => b.toString
-    case And(And(e1,e2),e3) => apply(And(e1,And(e2,e3)),vl)
-    case And(e1,e2:And)     => s"${showP(e1,vl)} & ${showP(e2,vl)}"
+    case And(And(e1,e2),e3) => apply(And(e1,And(e2,e3)),vl) 
+    case And(e1,e2:And)     => s"${showP(e1,vl)} & ${showP(e2,vl)}" 
     case And(e1, e2) => s"${showP(e1,vl)} & ${showP(e2,vl)}"
     case Or(e1, e2)  => s"${showP(e1,vl)} | ${showP(e2,vl)}"
-    case Not(e1)     => s"not${showP(e1,vl)}"
+    case Not(EQ(l1,l2)) => s"${apply(l1,vl)}!=${apply(l2,vl)}"
+    case Not(e1)     => s"!(${showP(e1,vl)})"
     case EQ(l1, l2)    => s"${apply(l1,vl)}==${apply(l2,vl)}"
     case GT(l1, l2)    => s"${apply(l1,vl)}>${apply(l2,vl)}"
     case LT(l1, l2)    => s"${apply(l1,vl)}<${apply(l2,vl)}"
     case GE(l1, l2)    => s"${apply(l1,vl)}>=${apply(l2,vl)}"
     case LE(l1, l2)    => s"${apply(l1,vl)}<=${apply(l2,vl)}"
   }
-
+  
   private def showP(exp:Cond, vl:Valuation):String = exp match {
-//    case _:Or | _:And => s"(${apply(exp,vl)})"
-//    case _ => apply(exp,vl)
     case BVal(b) => b.toString
     case _ => s"(${apply(exp,vl)})"
   }
 
+
+  private def showVarNotLin(v: VarNotLin, valuation: Valuation,cont:SyExpr => String): String = {
+    valuation.get(v.v) match {
+      case Some(exp) => cont(Eval.updInput(exp,valuation))  
+      case None => v.v 
+    }
+  }
+
+
+/*
   private def showVar(v: Var, valuation: Valuation,cont:SyExpr => String): String = {
     valuation.get(v.v) match {
-      case Some(exp) => cont(Eval.updInput(exp,valuation))
-      case None => v.v
+      case Some(exp) => cont(Eval.updInput(exp,valuation))  
+      case None => v.v 
     }
   }
+*/
+
 
   def apply[E<:SymbolicExpr.All](expr: SymbolicExpr[E]): String = expr match {
     case SVal(v) => floatToFraction(v) //f"$v%1.8f"
     case _:SArg  => "_t_"
     case s:SVar  => s.v
-    case s:SFun[E]  => s"${s.f}(${s.args.map(apply[E]).mkString(",")})"
+    case SFun("PI",Nil) => "pi"
+    case SFun("E",Nil) => "e"
+    //case SFun("log10",list) => s"log(${list.map(apply).mkString(",")})/log(10)"
+    case s:SFun[E]  => {
+      if(s.f!="log10") s"${s.f}(${s.args.map(apply[E]).mkString(",")})"
+      else s"log(${s.args.map(apply[E]).mkString(",")})/log(10)"
+    }
     case s:SDiv[E]  => s"${applyP[E](s.e1)}/${applyP[E](s.e2)}"
+    case s:SRes[E]  => s"${applyP[E](s.e1)}%${applyP[E](s.e2)}"
     case s:SMult[E] => s"${applyP[E](s.e1)}*${applyP[E](s.e2)}"
     case s:SPow[E]  => s"${applyP[E](s.e1)}^${applyP[E](s.e2)}"
     case s:SAdd[E]  => s"${applyP[E](s.e1)}+${applyP[E](s.e2)}"
@@ -124,19 +250,22 @@ object Show {
     case SMult(SArg(),d@SVal(_))=> s"${pp[E](d)}t"
     case SMult(d@SVal(_),SVar(x))=> s"${pp[E](d)}$x"
     case SMult(d@SVal(_),SArg())=> s"${pp[E](d)}t"
-//    case SMult(e1,e2@SAdd(_,_))=> s"${ppP[E](e1)}*${ppP[E](e2)}"
     case SAdd(SVal(0),e)=> s"${pp[E](e)}"
     case SAdd(e,SVal(0))=> s"${pp[E](e)}"
     case SAdd(e1,e2@SAdd(_,_)) => s"${ppP[E](e1)}+${pp[E](e2)}"
-//    case SSub(e1,e2@SAdd(_,_)) => s"${ppP[E](e1)}-${ppP[E](e2)}"
-//    case SMult(e1@SAdd(_,_),e2)=> s"${ppP[E](e1)}*${ppP[E](e2)}"
     case SAdd(e1@SAdd(_,_),e2)=> s"${pp[E](e1)}+${ppP[E](e2)}"
-//    case SSub(e1@SAdd(_,_),e2)=> s"${ppP[E](e1)}-${ppP[E](e2)}"
     case SSub(SVal(0),e)=> s"-${ppP[E](e)}"
     case SSub(e,SVal(0))=> s"${pp[E](e)}"
     //// General cases
-    case s:SFun[E]  => s"${s.f}(${s.args.map(pp[E]).mkString(",")})"
+    case SFun("PI",Nil) => "pi"
+    case SFun("E",Nil) => "e"
+    //case SFun("log10",list) => s"log(${list.map(pp).mkString(",")})/log(10)"
+    case s:SFun[E]  => {
+      if (s.f != "log10") s"${s.f}(${s.args.map(pp[E]).mkString(",")})"
+      else s"log(${s.args.map(pp[E]).mkString(",")})/log(10)"
+    }
     case s:SDiv[E]  => s"${ppP[E](s.e1)}/${ppP[E](s.e2)}"
+    case s:SRes[E]  => s"${ppP[E](s.e1)}%${ppP[E](s.e2)}"
     case s:SMult[E] => s"${ppP[E](s.e1)}*${ppP[E](s.e2)}"
     case s:SPow[E]  => s"${ppP[E](s.e1)}^${ppP[E](s.e2)}"
     case s:SAdd[E]  => s"${ppP[E](s.e1)}+${ppP[E](s.e2)}"
@@ -162,115 +291,22 @@ object Show {
   }
 
 
-  def floatToFraction(v: Double): String = {
+  def floatToFraction(v: Double): String = try {
     var den: BigInt = 1
     var num: BigDecimal = v
     while (num.toBigIntExact.isEmpty) { // && num < BigDecimal.apply("100000000000000000000000")) {
       num *= 10
       den *= 10
-      //println(s"   - $num/$den")
     }
-    //println(s"-- $v -> ${num.toBigInt.toString}/${den.toString}")
     if (den == 1) num.toBigInt.toString
     else s"${num.toBigInt.toString}/${den.toString}"
+    } catch {
+    case e: java.lang.NumberFormatException => "NaN"
   }
 
-
   def apply(r:RunTarget): String = r match {
     case Traj.Time(t) => apply(t)
     case Traj.Times(from,to,step) => s"${from.toString}:${step.toString}:${to.toString}" //ts.map(apply[SymbolicExpr.All]).mkString(", ")
     case Traj.Bound(n,timer) => s"forever ($n loop iterations, max $timer time)"
   }
-
-  //  def apply(p:Progr): String = p match {
-//    case Seq(ps) => ps.map(apply).mkString(" ; ")
-//    case Statement(as,Some(dur)) => addPar(as.map(apply)) +" & "+ apply(dur)
-//    case Statement(as,None) => as.map(apply).mkString(", ")
-//  }
-//
-//  def apply(a:Assgn): String = a match {
-//    case Assgn(v,e) => s"${apply(v)}:=${apply(e)}"
-//  }
-//
-//  private def addPar(l:List[String]): String = l match {
-//    case _::_::_ =>l.mkString("(",", ",")")
-//    case _ => l.mkString(", ")
-//  }
-//
-//
-//  def apply(exp: Expr): String = exp match {
-//    case Val(n) => n.toString
-//    case Var(x,n) => x+(for (_<-1 to n) yield '\'').mkString("")
-//    case Add(e1,e2) => s"${showP(e1)} + ${showP(e2)}"
-//    case Sub(e1,e2) => s"${showP(e1)} - ${showP(e2)}"
-//    case Mul(e1,e2) => s"${showP(e1)} * ${showP(e2)}"
-//    case Div(e1,e2) => s"${showP(e1)} / ${showP(e2)}"
-//     // bools
-//    case BVal(b) => b.toString
-//    case EQ(e1, e2)  => s"${showP(e1)} == ${showP(e2)}"
-//    case GT(e1, e2)  => s"${showP(e1)} > ${showP(e2)}"
-//    case LT(e1, e2)  => s"${showP(e1)} < ${showP(e2)}"
-//    case GE(e1, e2)  => s"${showP(e1)} >= ${showP(e2)}"
-//    case LE(e1, e2)  => s"${showP(e1)} <= ${showP(e2)}"
-//    case And(Nil)    => ""
-//    case And(e::Nil) => apply(e)
-//    case And(es)     => es.map(showP).mkString(" && ")
-//    case Or(e1, e2)  => s"${showP(e1)} || ${showP(e2)}"
-//    case Not(e1)     => s"!${showP(e1)}"
-//
-//  }
-//
-//  private def showP(exp:Expr):String = exp match {
-//    case BVal(_) | Val(_) | Var(_,_) | Not(_) => apply(exp)
-//    case _ => s"(${apply(exp)})"
-//
-//  }
-//
-////   ////////////////
-////   //
-//  def source(progr: Progr): String = progr match {
-//    case Seq(ps) => "Seq("+ps.map(source).map(indent).mkString("","\n",")")
-//    case Statement(st, dur) => s"Statement(\n  st:  ${st.map(source).mkString(", ")}"+
-//      (dur match {
-//        case Some(e) => s"\n  dur: ${apply(e)} )"
-//        case None => ")"
-//      })
-//}
-//  def source(assgn: Assgn): String = {
-//    s"Var(${assgn.v.name}, ${assgn.v.der}) := Expr(${assgn.e})"
-//  }
-//  def indent(s:String):String = {
-//    s.split("\n").map("  "+_).mkString("\n")
-//  }
-
-
-//
-//     case Seq(c1, c2)    => s"${showSP(c1)} & ${showSP(c2)}"
-//     case Par(c1, c2)    => s"${showSP(c1)} * ${showSP(c2)}"
-//     case Id(Port(IVal(1))) => "id"
-//     case Id(Port(IVal(0))) => "(id^0)"
-//     case Id(x)          => s"(id^${showP(x)})"
-//     case Symmetry(i, j) => s"sym(${apply(i)},${apply(j)})"
-//     case Trace(i, c)    => s"Tr(${apply(i)},${source(c)})"
-//     case Prim(name,_,_,_) => name
-//     case Exp(a, c)  => s"${showSP(c)}^${showP(a)}"
-//     case ExpX(x, a, c)  => s"(${showSP(c)}^(${apply(x)}<--${showP(a)}))"
-//     case Choice(b, c1, c2) => s"${showP(b)} ? ${showSP(c1)} + ${showSP(c2)}"
-     //s"if ${showP(b)} then ${showP(c1)} else ${showP(c2)}"
-
-//     case Abs(x,et,c)   => s"lam(${apply(x)},${apply(et)},${source(c)})"
-// //    case BAbs(x, c)     => s"lam(${apply(x)}${source(c)})"
-//     case App(c, a)     => s"${showSP(c)}(${apply(a)})"
-// //    case BApp(c, b)     => s"${showSP(c)}(${apply(b)})"
-//     case Restr(c,b)     => s"${showSP(c)} | ${showP(b)}"
-//
-//     case SubConnector(name, c, _) => if (name=="") showSP(c) else name + s"{${showSP(c)}}"
-//   }
-
-//   private def showSP(con:Connector): String = con match {
-//     case Seq(_,_) | Par(_,_) | Choice(_,_,_) | Abs(_,_,_) |
-//          Exp(_,_) | ExpX(_,_,_) | Restr(_,_) => s"(${source(con)})"
-//     case _ => source(con)
-//   }
-
 }
\ No newline at end of file
diff --git a/src/main/scala/hprog/backend/TrajToJS.scala b/src/main/scala/hprog/backend/TrajToJS.scala
old mode 100644
new mode 100755
index 7e0c68a..9b25373
--- a/src/main/scala/hprog/backend/TrajToJS.scala
+++ b/src/main/scala/hprog/backend/TrajToJS.scala
@@ -13,15 +13,13 @@ object TrajToJS {
   private type BoundaryVar = Map[Either[Double,Double],(Double,String)] // left/right of a time t -> value and comment
 
 
-  def apply(traj:Traj, divName:String, range:Option[(Double,Double)]=None, hideCont:Boolean=true): String = {
-
-    ////println("> starting script generation")
+  def apply(traj:Traj,divName:String, range:Option[(Double,Double)]=None, hideCont:Boolean=true): String = {
+    
     val dur = traj.getDur
 
     // trick to avoid many sampling when already lots of boundaries exist
     val nbrSamples = 0.max(100 - traj.getInits.getOrElse(Map()).size)
 
-    ////println(s"> run 1 completed - got duration $dur & boundary points")
 
     val max: Double = Eval(dur.getOrElse(SVal(10)),0)
 
@@ -55,21 +53,12 @@ object TrajToJS {
     // checks if a time value is within the scope
     def inScope(t:Double): Boolean = t>=start && t<=end
 
-    ////println(s"> starting run 2 ($nbrSamples samples)")
-//    println(s"> "+samples.mkString(","))
 
     val sampleValues = traj.evalBatch(SVal(start),SVal(end), SDiv(SSub(SVal(end),SVal(start)),SVal(nbrSamples))) //(samples)
 
-    ////println("> run 2 completed - got samples")
 
     for ((t,x) <- sampleValues; (variable,value) <- x)
       traces += variable -> (traces(variable) + (Eval(t)->Left(Eval(value))))
-//    for (t: Double <- samples)
-//      for (x <- traj.eval(t); (variable, value) <- x)
-//        traces += variable -> (traces(variable) + (t->Left(value)))
-    //      println("d")
-
-    ////println("> building boundaries, warnings, and notes")
     // Add ending points to "boundaries" and to "traces"
     for (e <- traj.getEnds;
          (t,endValues) <- e if inScope(Eval(t,0));
@@ -123,12 +112,10 @@ object TrajToJS {
     /////
     var js = "var colors = Plotly.d3.scale.category10();\n"
 
-    //      println("e")
 
     js += buildTraces(traces,colorIDs)
     js += buildBoundaries(boundaries,colorIDs)
     js += buildWarnings(traj,inScope,colorIDs)
-    ////println("> done")
 
 
     val traceNames = traces.keys.map("t_"+_).toList ++
@@ -141,7 +128,6 @@ object TrajToJS {
       s"\nvar layout = {hovermode:'closest'};" +
       s"\nPlotly.newPlot('$divName', data, layout, {showSendToCloud: true});"
 
-    //println("JS:\n"+js)
     js
   }
 
@@ -159,8 +145,8 @@ object TrajToJS {
            |   y: ${ys.mkString("[",",","]")},
            |   mode: 'lines',
            |   line: {color: colors(${colorIDs.getOrElse(variable,0)})},
-           |   legendgroup: 'g_$variable',
-           |   name: '$variable'
+           |   legendgroup: 'g_${remove_variable(variable)}',
+           |   name: '${remove_variable(variable)}'
            |};
              """.stripMargin
     }
@@ -200,7 +186,11 @@ object TrajToJS {
     js
   }
 
-
+ def remove_variable(variable:String):String = {
+  //var aux=variable.substring(0,variable.length-1)
+  var aux=variable.substring(1,variable.length)
+  return aux
+ }
 
   private def expandPoint(point:(Double,Either[Double,(Double,Double)])): List[(Double,String)] =
     point match {
@@ -232,8 +222,8 @@ object TrajToJS {
        |   mode: 'markers',
        |   marker: $style,
        |   type: 'scatter',
-       |   legendgroup: 'g_$variable',
-       |   name: 'boundary of $variable',
+       |   legendgroup: 'g_${remove_variable(variable)}',
+       |   name: 'boundary of ${remove_variable(variable)}',
        |   showlegend: false
        |};""".stripMargin
 
@@ -248,18 +238,13 @@ object TrajToJS {
         val values = (ends ++ inits).map(kv => Eval(kv._1) -> kv._2)
         val (x,y,msg) = warns
           .toList
-          // list: timeExpr->warning
           .map(es => (Eval(es._1, 0), "'" + fixStr(es._2) + "'"))
-          // list realTime -> fixedWarning
           .filter(es => inScope(es._1))
-          // list with in-scope realTime
           .sorted
-          // sorted list
           .map(warn=>(warn._1, Eval(
             values.getOrElse(warn._1,Map():Valuation) // get Valuation at warning warn
                   .getOrElse(variable, SVal(0)) // get expression of Variable
             ), warn._2))
-          // for each rt->warn, find the valuation of "rt", find the variable, and get its value
           .unzip3
 
         s"""var w_$variable = {
@@ -269,7 +254,7 @@ object TrajToJS {
            |   mode: 'markers',
            |   marker: $style,
            |   type: 'scatter',
-           |   legendgroup: 'g_$variable',
+           |   legendgroup: 'g_${remove_variable(variable)}',
            |   name: 'Warning',
            |   showlegend: false
            |};""".stripMargin
diff --git a/src/main/scala/hprog/common/ParserException.scala b/src/main/scala/hprog/common/ParserException.scala
old mode 100644
new mode 100755
diff --git a/src/main/scala/hprog/common/TimeOutOfBoundsException.scala b/src/main/scala/hprog/common/TimeOutOfBoundsException.scala
old mode 100644
new mode 100755
diff --git a/src/main/scala/hprog/common/TimeoutException.scala b/src/main/scala/hprog/common/TimeoutException.scala
old mode 100644
new mode 100755
index 1a66dc3..8e2bb66
--- a/src/main/scala/hprog/common/TimeoutException.scala
+++ b/src/main/scala/hprog/common/TimeoutException.scala
@@ -1,3 +1,3 @@
 package hprog.common
 
-class TimeoutException(s:String) extends RuntimeException(s"Stopped waiting for Sage. This timeout is normal in the first execution of Lince, because the associated systems need to be started. Please try again. $s")
+class TimeoutException(s:String) extends RuntimeException(s"(Stopped waiting for Sage. This timeout is normal in the first execution of Lince, because the associated systems need to be started. Please try again.)\n\n $s")
diff --git a/src/main/scala/hprog/common/TypeCheckException.scala b/src/main/scala/hprog/common/TypeCheckException.scala
old mode 100644
new mode 100755
diff --git a/src/main/scala/hprog/frontend/CommonTypes.scala b/src/main/scala/hprog/frontend/CommonTypes.scala
old mode 100644
new mode 100755
index 4dd70b4..934f362
--- a/src/main/scala/hprog/frontend/CommonTypes.scala
+++ b/src/main/scala/hprog/frontend/CommonTypes.scala
@@ -2,6 +2,11 @@ package hprog.frontend
 
 import hprog.ast.SymbolicExpr.{SyExpr, SyExprAll, SyExprTime, SyExprVar}
 
+
+
+
+
+
 object CommonTypes {
 
   // symbolic level
@@ -22,6 +27,27 @@ object CommonTypes {
   type Warnings = Set[(SyExpr,String)]
   type Notes    = Set[(SyExpr,String)]
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 //
 //
 //
diff --git a/src/main/scala/hprog/frontend/Deviator.scala b/src/main/scala/hprog/frontend/Deviator.scala
old mode 100644
new mode 100755
index 505bf5a..9d175cc
--- a/src/main/scala/hprog/frontend/Deviator.scala
+++ b/src/main/scala/hprog/frontend/Deviator.scala
@@ -1,6 +1,7 @@
 package hprog.frontend
 
-import hprog.ast.Cond
+import hprog.ast._
+import Syntax._
 import hprog.frontend.CommonTypes.Point
 
 trait Deviator {
diff --git a/src/main/scala/hprog/frontend/Distance.scala b/src/main/scala/hprog/frontend/Distance.scala
old mode 100644
new mode 100755
index 90ae6df..7abec04
--- a/src/main/scala/hprog/frontend/Distance.scala
+++ b/src/main/scala/hprog/frontend/Distance.scala
@@ -3,12 +3,15 @@ package hprog.frontend
 //import breeze.numerics.{pow, sqrt}
 import hprog.ast
 import hprog.ast._
+import Syntax._
 import hprog.frontend.CommonTypes.Point
 import optimus.algebra.{Constraint, Expression}
 import optimus.optimization._
 import optimus.optimization.enums.SolverLib
 import optimus.optimization.model.{MPFloatVar, MPVar}
 
+import scala.math._
+
 class Distance(eps:Double) extends Deviator {
   override def closest(p: Point, cond: Cond): Option[Point] =
     Distance.closest(p,cond,eps)
@@ -23,6 +26,9 @@ object Distance {
     * @param max maximum distance to search
     * @return some closest point within c and not further than `max`
     */
+
+
+
   def closest(p:Point,c:Cond,max:Double): Option[Point] = {
     val res = if (max<=0) {
       if (normaliseCond(c) contains p) Some(p) else None
@@ -30,11 +36,12 @@ object Distance {
     else closest(p, normaliseCond(c), max).flatMap(p2 =>
         if (dist(p,p2)<=max) Some(p2) else None
     )
-    //println(s"got closest to ${p} when ${Show(c)} - ${res}")
+   
     res
   }
 
 
+
   type DNF = Or
   case class Or(ands:Set[And]) {
     def contains(p:Point): Boolean = ands.exists(_ contains p)
@@ -44,50 +51,58 @@ object Distance {
   }
   sealed abstract class Ineq {
     def contains(p:Point): Boolean = this match {
-      //case EQ(l1, l2) => Eval(p,l1) == Eval(p,l2)
       case GT(l1, l2) => Eval(p,l1) >  Eval(p,l2)
       case LT(l1, l2) => Eval(p,l1) <  Eval(p,l2)
       case GE(l1, l2) => Eval(p,l1) >= Eval(p,l2)
       case LE(l1, l2) => Eval(p,l1) <= Eval(p,l2)
     }
   }
-  //  case class EQ(l1:Lin,l2:Lin)      extends Ineq
-  case class GT(l1:Lin,l2:Lin)      extends Ineq
-  case class LT(l1:Lin,l2:Lin)      extends Ineq
-  case class GE(l1:Lin,l2:Lin)      extends Ineq
-  case class LE(l1:Lin,l2:Lin)      extends Ineq
 
 
 
+  // New
+  case class GT(l1:NotLin,l2:NotLin)      extends Ineq
+  case class LT(l1:NotLin,l2:NotLin)      extends Ineq
+  case class GE(l1:NotLin,l2:NotLin)      extends Ineq
+  case class LE(l1:NotLin,l2:NotLin)      extends Ineq
+
+//////////////////////////////////////////////////////////////////
+
+// New
   def normaliseCond(c:Cond): DNF = c match {
     case BVal(true) => Or(Set(And(Set())))
-    case BVal(false) => Or(Set())
-    case ast.And(c1, c2) => (normaliseCond(c1),normaliseCond(c2)) match {
+    case BVal(false) => Or(Set()) 
+    case ast.Syntax.And(c1, c2) => (normaliseCond(c1),normaliseCond(c2)) match {
       case (Or(ands1),Or(ands2)) => Or( for(a1<-ands1;a2<-ands2) yield And(a1.ineqs++a2.ineqs))
     }
-    case ast.Or(c1, c2) =>  (normaliseCond(c1),normaliseCond(c2)) match {
+    case ast.Syntax.Or(c1, c2) =>  (normaliseCond(c1),normaliseCond(c2)) match {
       case (Or(ands1), Or(ands2)) => Or(ands1++ands2)
     }
     case Not(c2) => normaliseCond(swapOps(c2))
-    case ast.EQ(v, l) => Or(Set(And(Set(GE(v,l),LE(v,l)))))
-    case ast.GT(v, l) => Or(Set(And(Set(GT(v,l)))))
-    case ast.LT(v, l) => Or(Set(And(Set(LT(v,l)))))
-    case ast.GE(v, l) => Or(Set(And(Set(GE(v,l)))))
-    case ast.LE(v, l) => Or(Set(And(Set(LE(v,l)))))
+    case ast.Syntax.EQ(l1, l2) => Or(Set(And(Set(GE(l1, l2),LE(l1, l2)))))
+    case ast.Syntax.GT(l1, l2) => Or(Set(And(Set(GT(l1, l2)))))
+    case ast.Syntax.LT(l1, l2) => Or(Set(And(Set(LT(l1, l2)))))
+    case ast.Syntax.GE(l1, l2) => Or(Set(And(Set(GE(l1, l2)))))
+    case ast.Syntax.LE(l1, l2) => Or(Set(And(Set(LE(l1, l2)))))
   }
+  
 
+  // Condition swap
   def swapOps(c: Cond): Cond = c match {
     case BVal(b)        => BVal(!b)
-    case ast.And(c1, c2)=> ast.Or(swapOps(c1),swapOps(c2))
-    case ast.Or(c1, c2) => ast.And(swapOps(c1),swapOps(c2))
+    case ast.Syntax.And(c1, c2)=> ast.Syntax.Or(swapOps(c1),swapOps(c2))
+    case ast.Syntax.Or(c1, c2) => ast.Syntax.And(swapOps(c1),swapOps(c2))
     case Not(c2)        => c2
-    case ast.EQ(v, l)   => ast.Or(ast.LT(v,l),ast.GT(v,l))
-    case ast.GT(v, l)   => ast.LE(v,l)
-    case ast.LT(v, l)   => ast.GE(v,l)
-    case ast.GE(v, l)   => ast.LT(v,l)
-    case ast.LE(v, l)   => ast.GT(v,l)
+    case ast.Syntax.EQ(l1, l2)   => ast.Syntax.Or(ast.Syntax.LT(l1, l2),ast.Syntax.GT(l1, l2))
+    case ast.Syntax.GT(l1, l2)   => ast.Syntax.LE(l1, l2)
+    case ast.Syntax.LT(l1, l2)   => ast.Syntax.GE(l1, l2)
+    case ast.Syntax.GE(l1, l2)   => ast.Syntax.LT(l1, l2)
+    case ast.Syntax.LE(l1, l2)   => ast.Syntax.GT(l1, l2)
   }
 
+///////////////////////////////////////////////////////////////////////////
+
+
   private def closest(p:Point, dnf:DNF, max:Double): Option[Point] = dnf.ands.headOption match {
     case Some(and) =>
       closest(p, and, max) match {
@@ -102,10 +117,6 @@ object Distance {
           closest(p, Or(dnf.ands.tail),max)
       }
     case None => None
-//      val p1 = closest(p1,and)
-//      val p2 = closest(p1,Or(dnf.ands.tail))
-//      if (dist(p,p1) <= dist(p,p2)) p1 else p2
-//    case None => throw new RuntimeException(s"No point in the domain of $dnf.")
   }
 
   def dist(p1:Point,p2:Point): Double = {
@@ -116,20 +127,14 @@ object Distance {
 
   def closest(p:Point,and:And,max:Double): Option[Point] =
     closest(p,and.ineqs.map(closeIneq),max)
-//      .flatMap(p2 =>
-//      if (and contains p2) Some(p2)
-//      else None
-//    )
+
 
 
   def closest(p:Point,ineqs:Set[Ineq],max:Double): Option[Point] = {
     for (ineq <- ineqs) {
-      //println(s"manual closest of ${p} to ${ineq}")
       val p2: Point = closest(p,ineq)
-      //println(s"got ${p2}")
       if (And(ineqs - ineq) contains p2) return Some(p2)
     }
-    // no trivial solution; solve quadratic programming optimisation problem
     quadraticProgrm(p,ineqs,max)
   }
 
@@ -145,11 +150,10 @@ object Distance {
     else closest(p,left(ineq),right(ineq))
   }
 
-  def closest(p:Point, l1:Lin, l2:Lin): Point = {
+  def closest(p:Point, l1:NotLin, l2:NotLin): Point = {
     val delta = neg(p)
-    val p1 = lin2point(shiftLin(l1,delta))
-    val p2 = lin2point(shiftLin(l2,delta))
-    //    val plane = add(add(p1,neg(p2)),neg(p)) // p1-p2 - p
+    val p1 = notlin2point(shiftNotLin(l1,delta))
+    val p2 = notlin2point(shiftNotLin(l2,delta))
     val plane = add(p1,neg(p2))
     val d = 0.0 - plane.getOrElse("",0.0) // extra value without variable from p1-p2
     val plane2 = plane - "" // take out empty variable
@@ -158,14 +162,98 @@ object Distance {
     add(p3 , p) // add point p in the end
   }
 
-  def lin2point(lin: Lin): Point = lin match {
-    case Var(v) => Map(v->1.0)
-    case Value(v) => Map("" -> v)
-    case Add(l1, l2) => add(lin2point(l1),lin2point(l2))
-    case Mult(v, l) => lin2point(l).view.mapValues(_ * v.v).toMap
-  }
+//New
+  def notlin2point(notlin: NotLin): Point = notlin match {
+    case VarNotLin(v) => Map(v->1.0)
+    case ValueNotLin(v) => Map("" -> v)
+    case AddNotLin(l1, l2) => add(notlin2point(l1),notlin2point(l2))
+    case MultNotLin(l1, l2) => mul(notlin2point(l1),notlin2point(l2))
+    case DivNotLin(l1, l2) => div(notlin2point(l1),notlin2point(l2))
+    case ResNotLin(l1, l2) => res(notlin2point(l1),notlin2point(l2))
+    case PowNotLin(l1, l2) => powdef(notlin2point(l1),notlin2point(l2))
+    case FuncNotLin(s,list) => funcdef(s,list.map((l:NotLin) => notlin2point(l)))
+   
+
+    }
+
+  // Why 'x' exist before '->'??  
   def add(p1:Point,p2:Point): Point =
-    p1 ++ (for ((x,v) <- p2) yield x -> (p1.getOrElse(x,0.0)+v))
+    p1 ++ (for ((x,v) <- p2) yield x -> (p1.getOrElse(x,0.0)+v)) // getOrElse remove the value of p1, if it not exist, return (x,0)
+
+
+//////////////////////////////////////////////////////////////////
+
+//New
+  def mul(p1:Point,p2:Point): Point=
+    p1 ++ (for ((x,v) <- p2) yield x -> (p1.getOrElse(x,1.0)*v))
+
+  def div(p1:Point,p2:Point): Point=
+    p1 ++ (for ((x,v) <- p2) yield x -> (if (p1.contains(x))  p1(x)/v else v)) 
+
+
+  def res(p1:Point,p2:Point): Point=
+    p1 ++ (for ((x,v) <- p2) yield x -> (if (p1.contains(x))  p1(x)%v else v))
+
+ 
+  def seno(p1:Map[String,Double]): Map[String,Double]=
+    p1.map(v => v._1 -> sin(v._2))
+  
+
+
+  def cosseno(p1:Map[String,Double]): Map[String,Double]=
+    p1.map(v => v._1 -> cos(v._2))
+
+
+  def tangente(p1:Map[String,Double]): Map[String,Double]=
+    p1.map(v => v._1 -> tan(v._2))
+
+
+  def powdef(p1:Map[String,Double],p2:Map[String,Double]): Map[String,Double]=
+   p1 ++ (for ((x,v) <- p2) yield x -> (if (p1.contains(x))  pow(p1(x),v) else v))
+
+  
+  def funcdef(s:String,list:List[Point]):Point ={
+    if(list.length == 0 || list.length>2){
+      s match {
+        case ("PI") => Map("" -> math.Pi)
+        case ("E") => Map("" -> math.E)
+        case (_) => throw new RuntimeException(s"Unknown function '${s}',or the number of arguments are incorrect")
+      }
+      
+    }
+    else {
+      if (list.length == 1){
+        s match {
+          case ("exp") => list(0).map(v => v._1 -> math.exp(v._2))
+          case ("sin") => list(0).map(v => v._1 -> math.sin(v._2))
+          case ("cos") => list(0).map(v => v._1 -> math.cos(v._2))
+          case ("tan") => list(0).map(v => v._1 -> math.tan(v._2))
+          case ("arcsin") => list(0).map(v => v._1 -> math.asin(v._2))
+          case ("arccos") => list(0).map(v => v._1 -> math.acos(v._2))
+          case ("arctan") => list(0).map(v => v._1 -> math.atan(v._2))
+          case ("sinh") => list(0).map(v => v._1 -> math.sinh(v._2))
+          case ("cosh") => list(0).map(v => v._1 -> math.cosh(v._2))
+          case ("tanh") => list(0).map(v => v._1 -> math.tanh(v._2))
+          case ("sqrt") => list(0).map(v => v._1 -> math.sqrt(v._2))
+          case ("log") => list(0).map(v => v._1 -> math.log(v._2))
+          case ("log10") => list(0).map(v => v._1 -> math.log10(v._2))
+          case (_)=>throw new RuntimeException(s"Unknown function '${s}',or the number of arguments are incorrect")
+        }
+      }
+      else {
+        s match {
+          case ("max") => list(0) ++ (for ((x,v) <- list(1)) yield x -> (if (list(0).contains(x))  math.max((list(0))(x),v) else v))
+          case ("min") => list(0) ++ (for ((x,v) <- list(1)) yield x -> (if (list(0).contains(x))  math.min((list(0))(x),v) else v))
+          case (_)=>throw new RuntimeException(s"Unknown function '${s}',or the number of arguments are incorrect")
+        }  
+      }
+
+    }
+  }
+
+  
+/////////////////////////////////////////////////////////////////
+
 
   def neg(p1:Point): Point =
     p1.view.mapValues(_*(-1)).toMap
@@ -176,15 +264,13 @@ object Distance {
     plane.view.mapValues(x => x*d/norm).toMap
   }
 
-  def left(ineq: Ineq): Lin = ineq match {
-    //case EQ(l1,_) => l1
+  def left(ineq: Ineq): NotLin = ineq match {
     case GT(l1,_) => l1
     case LT(l1,_) => l1
     case GE(l1,_) => l1
     case LE(l1,_) => l1
   }
-  def right(ineq: Ineq): Lin = ineq match {
-    //case EQ(_,l2) => l2
+  def right(ineq: Ineq): NotLin = ineq match {
     case GT(_,l2) => l2
     case LT(_,l2) => l2
     case GE(_,l2) => l2
@@ -195,26 +281,34 @@ object Distance {
   // need to shift based on `max` because variables will only get positive values
   def quadraticProgrm(p: Point, ineqs: Set[Ineq], max:Double): Option[Point] = {
     val delta = p.view.mapValues(x => if (x<max) max-x else 0).toMap
-    //println(s"before: ${ineqs.mkString(", ")}")
-    //println(s"delta: ${delta.map(kv=>kv._1+"->"+kv._2).mkString(", ")}")
     val shiftedP = add(p,delta)
     val shiftedIneqs = ineqs.map(i => shiftIneq(i,delta))
-    //println(s"after:  ${shiftedIneqs.mkString(", ")}")
     quadraticProgrm(shiftedP,shiftedIneqs)
       .map(p2 => add(p2,neg(delta)))
   }
 
   def shiftIneq(ineq: Ineq, delta:Point): Ineq = ineq match {
-    case GT(l1, l2) => GT(shiftLin(l1,delta),shiftLin(l2,delta))
-    case LT(l1, l2) => LT(shiftLin(l1,delta),shiftLin(l2,delta))
-    case GE(l1, l2) => GE(shiftLin(l1,delta),shiftLin(l2,delta))
-    case LE(l1, l2) => LE(shiftLin(l1,delta),shiftLin(l2,delta))
+    case GT(l1, l2) => GT(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case LT(l1, l2) => LT(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case GE(l1, l2) => GE(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case LE(l1, l2) => LE(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
   }
-  def shiftLin(lin: Lin, delta:Point): Lin = lin match {
-    case Var(v) => if (delta(v)!=0) Add(lin,Value(-delta(v))) else lin
-    case Value(_) => lin
-    case Add(l1, l2) => Add(shiftLin(l1,delta),shiftLin(l2,delta))
-    case Mult(v, l) => Mult(v,shiftLin(l,delta))
+
+
+
+
+  //New
+  def shiftNotLin(notlin: NotLin, delta:Point): NotLin = notlin match {
+    case VarNotLin(v) => if (delta(v)!=0) AddNotLin(notlin,ValueNotLin(-delta(v))) else notlin // Porquê o menos ??
+    case ValueNotLin(_) => notlin
+    case AddNotLin(l1, l2) => AddNotLin(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case MultNotLin(l1, l2) => MultNotLin(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case DivNotLin(l1,l2) => DivNotLin(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case ResNotLin(l1,l2) => ResNotLin(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case PowNotLin(l1,l2) => PowNotLin(shiftNotLin(l1,delta),shiftNotLin(l2,delta))
+    case FuncNotLin(s,list)=> FuncNotLin(s,list.map((l:NotLin) => shiftNotLin(l,delta)))
+
+     
   }
 
 
@@ -231,18 +325,18 @@ object Distance {
 
     val sumSquares: Expression = squares.fold(0:Expression)(_+_)
 
-    //println(s"minimizing: $sumSquares")
+ 
     minimize(sumSquares)(model)
 
     // subject to constraints
     for (ineq<-ineqs) {
-      ///println(s"add constraint: ${ineqToConstr(ineq,vars)}")
+     
       subjectTo(ineqToConstr(ineq, vars))(model)
     }
 
-    //println(s"constraints: ${ineqs.mkString(",")}")
+  
     val ok = start()(model)
-    //println(s" - $ok")
+   
 
     release()(model)
 
@@ -256,52 +350,23 @@ object Distance {
     else
       None
 
-    /*
-import optimus.optimization._
-import optimus.optimization.enums.SolverLib
-import optimus.optimization.model.MPFloatVar
-
-implicit val model = MPModel(SolverLib.oJSolver)
-
-  Ok! Let's create a couple of variables:
-
-// Both variables are positive, that is, bounds are in [0, +inf]
-val x = MPFloatVar.positive("x")
-val y = MPFloatVar.positive("y")
-
-  Then we can define our optimization problem subject to a couple of constraints using our known maths:
-
-minimize(-8*x - 16*y + x*x + 4*y^2)
-subjectTo(
-          x + y <:= 5,
-          x <:= 3
-         )
-  At last, we can solve the problem by starting the solver and displaying the results:
-
-start()
-println(s"objective: $objectiveValue")
-println(s"x = ${x.value} y = ${y.value}")
-
-  Finally, don't forget to release the memory used by the internal solver:
-
-release()
-     */
+ 
   }
 
   def ineqToConstr(ineq: Ineq, vars: Map[String, MPVar]): Constraint = {
-    val small:Point = lin2point(smallPart(ineq))
-    val big:Point   = lin2point(bigPart(ineq))
+    val small:Point = notlin2point(smallPart(ineq))
+    val big:Point   = notlin2point(bigPart(ineq))
 
     point2Expr(small,vars) <:= point2Expr(big,vars)
   }
 
-  def smallPart(ineq: Ineq): Lin = ineq match {
+  def smallPart(ineq: Ineq): NotLin = ineq match {
     case GT(_, l2) => l2
     case LT(l1, _) => l1
     case GE(_, l2) => l2
     case LE(l1, _) => l1
   }
-  def bigPart(ineq: Ineq): Lin = ineq match {
+  def bigPart(ineq: Ineq): NotLin = ineq match {
     case GT(l1, _) => l1
     case LT(_, l2) => l2
     case GE(l1, _) => l1
@@ -321,7 +386,6 @@ release()
     val c = hprog.lang.Parser.parseAll(hprog.lang.Parser.condP,s)
     c match {
       case hprog.lang.Parser.Success(cond, _) =>
-        //println("parsed")
         val res = closest(p,cond,max)
         if (res.isEmpty) println("no closest point")
         else
diff --git a/src/main/scala/hprog/frontend/Eval.scala b/src/main/scala/hprog/frontend/Eval.scala
old mode 100644
new mode 100755
index b1d6ac1..c1666b4
--- a/src/main/scala/hprog/frontend/Eval.scala
+++ b/src/main/scala/hprog/frontend/Eval.scala
@@ -2,26 +2,92 @@ package hprog.frontend
 
 import hprog.ast.SymbolicExpr.{SyExpr, SyExprAll, SyExprTime, SyExprVar}
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.frontend.CommonTypes.{Point, SySolution, SySolutionTime, SySolutionVar, Valuation, Solution}
 import hprog.frontend.solver.Solver
-
+import scala.math._
 import scala.sys.error
 
 object Eval {
 
-//  private type ST = SyExprTime
-//  private type SE = SyExpr
-//  private type SA = SyExprAll
-//  private type SV = SyExprVar
 
+
+//////////////////////////////////////////////////////////////////////////////
+
+/*
+  /** Evaluation of a linear expression. */
   def apply(state:Point, lin: Lin): Double = lin match {
     case Var(v) => state(v)
     case Value(v) => v
     case Add(l1, l2) => apply(state,l1) + apply(state,l2)
-    case Mult(v, l)  => apply(state,v)  * apply(state,l)
+    case Mult(l1,l2)  => apply(state,l1)  * apply(state,l2)
+   
+  }
+*/
+
+  /** Evaluation of a non-linear expression. */
+  def apply(state:Point, notlin: NotLin): Double = {
+    val res = notlin match {
+            case VarNotLin(v) => state(v)
+            case ValueNotLin(v) => v
+            case AddNotLin(l1, l2) => apply(state,l1) + apply(state,l2)
+            case MultNotLin(l1,l2)  => apply(state,l1)  * apply(state,l2)
+            case DivNotLin(l1,l2)  => apply(state,l1) / apply(state,l2)
+            case ResNotLin(l1,l2)  => apply(state,l1) % apply(state,l2)
+            case PowNotLin(l1,l2)  => pow(apply(state,l1),apply(state,l2))
+            case FuncNotLin(s,list) => (s,list) match {
+              case ("PI",Nil) => math.Pi
+              case ("E",Nil) => math.E
+              case ("max",v1::v2::Nil) => math.max(apply(state,v1), apply(state,v2))
+              case ("min",v1::v2::Nil) => math.min(apply(state,v1), apply(state,v2))
+              case ("exp",v::Nil) => math.exp(apply(state,v))
+              case ("sin",v::Nil) => math.sin(apply(state,v))
+              case ("cos",v::Nil) => math.cos(apply(state,v))
+              case ("tan",v::Nil) => math.tan(apply(state,v))
+              case ("arcsin",v::Nil) => math.asin(apply(state,v))
+              case ("arccos",v::Nil) => math.acos(apply(state,v))
+              case ("arctan",v::Nil) => math.atan(apply(state,v))
+              case ("sinh",v::Nil) => math.sinh(apply(state,v))
+              case ("cosh",v::Nil) => math.cosh(apply(state,v))
+              case ("tanh",v::Nil) => math.tanh(apply(state,v))
+              case ("sqrt",v::Nil) => math.sqrt(apply(state,v))
+              case ("log",v::Nil) => math.log(apply(state,v))
+              case ("log10",v::Nil) => math.log10(apply(state,v))
+              case (_,_) => throw new RuntimeException(s"Unknown function '${s}(${list.mkString(",")})', or the number of arguments are incorrect")
+
+            }
+    
   }
+  println(s"Eval: notlin->${notlin} to ${res}")
+  res
+}
+
+  def updateNotlin(state:Point, notlin: NotLin,vars:List[String]): NotLin = {
+    val res = notlin match {
+            case VarNotLin(v) => {if (vars.contains(v)) {VarNotLin(v)} else {ValueNotLin(state(v))} }
+            case ValueNotLin(v) => ValueNotLin(v)
+            case AddNotLin(l1, l2) => AddNotLin(updateNotlin(state,l1,vars), updateNotlin(state,l2,vars))
+            case MultNotLin(l1,l2)  => MultNotLin(updateNotlin(state,l1,vars), updateNotlin(state,l2,vars))
+            case DivNotLin(l1,l2)  => DivNotLin(updateNotlin(state,l1,vars), updateNotlin(state,l2,vars))
+            case ResNotLin(l1,l2)  => ResNotLin(updateNotlin(state,l1,vars), updateNotlin(state,l2,vars))
+            case PowNotLin(l1,l2)  => PowNotLin(updateNotlin(state,l1,vars), updateNotlin(state,l2,vars))
+            case FuncNotLin(s,list) => FuncNotLin(s,list.map(l=>updateNotlin(state,l,vars)).toList)
 
+            }
+    res
+}
+
+ // The purpose of this function is to replace the constant variables of a diff.eq. by their respective constant values 
+  def updateDiffEq(diffeq:DiffEq,point:Point,vars:List[String]):DiffEq = {
+     
+     var newNotLin= updateNotlin(point,diffeq.e,vars)
+     var newdiffeq= DiffEq(diffeq.v,newNotLin)
+     return newdiffeq
+  }
+
+
+  // New
   def apply(state:Point, cond: Cond): Boolean =
     cond match {
       case BVal(b) =>  b
@@ -33,28 +99,37 @@ object Eval {
       case LT(v, l) => apply(state,v) <  apply(state,l)
       case GE(v, l) => apply(state,v) >= apply(state,l)
       case LE(v, l) => apply(state,v) <= apply(state,l)
+      
     }
 
-  def apply(e:SyExprAll, t: Double, x: Valuation): Double = e match {
+
+///////////////////////////////////////////////////////////////////////////////////////////
+
+  def apply(e:SyExprAll, t: Double, x: Valuation): Double = {
+    val res = e match {
     case SVal(v) => v
     case _:SArg => t
+    case SVar("e")  if !x.contains("e")  => math.E
+    case SVar("pi") if !x.contains("pi") => math.Pi
     case s:SVar if !x.contains(s.v) =>
-      throw new RuntimeException(s"Evaluating $e but ${s.v} not found in ${Show(x)}.")
+      throw new RuntimeException(s"Evaluating $e but ${s.v} not found in [${Show(x)}].")
     case s:SVar => apply(x(s.v),t,x)
-//    case SVar(v) => apply(x(v),t,x) // not really used - usually v(0) denotes this case
-                                           // could create an infinte loop if recursive (not anymore with SExpr)
-    case SDiv(e1, e2) => apply(e1,t,x) / apply(e2,t,x)
+    case SDiv(e1, e2) => apply(e1,t,x) / apply(e2,t,x)                  
+    case SRes(e1, e2) => apply(e1,t,x) % apply(e2,t,x)
     case SMult(e1, e2) =>apply(e1,t,x) * apply(e2,t,x)
     case SPow(e1, e2) => math.pow(apply(e1,t,x),apply(e2,t,x))
     case SAdd(e1, e2) => apply(e1,t,x) + apply(e2,t,x)
     case SSub(e1, e2) => apply(e1,t,x) - apply(e2,t,x)
     case s:SFun[SymbolicExpr.All] => (s.f,s.args) match {
       case (v,List(SVal(0.0))) if x contains v => apply(x(v),t,x) // could create infinite loop
+      case ("PI",Nil) => math.Pi
+      case ("E",Nil) => math.E
       case ("max",v1::v2::Nil) => math.max(apply(v1,t,x), apply(v2,t,x))
+      case ("min",v1::v2::Nil) => math.min(apply(v1,t,x), apply(v2,t,x))
       case ("exp",v::Nil) => math.exp(apply(v,t,x))
       case ("sin",v::Nil) => math.sin(apply(v,t,x))
       case ("cos",v::Nil) => math.cos(apply(v,t,x))
-      case ("tan",v::Nil) => math.atan(apply(v,t,x))
+      case ("tan",v::Nil) => math.tan(apply(v,t,x))
       case ("arcsin",v::Nil) => math.asin(apply(v,t,x))
       case ("arccos",v::Nil) => math.acos(apply(v,t,x))
       case ("arctan",v::Nil) => math.atan(apply(v,t,x))
@@ -65,17 +140,26 @@ object Eval {
       case ("log",v::Nil) => math.log(apply(v,t,x))
       case ("log10",v::Nil) => math.log10(apply(v,t,x))
       case (_,_) => throw new RuntimeException(
-        s"Unknown function '${s.f}(${s.args.mkString(",")})'")
+        s"Unknown function '${s.f}(${s.args.mkString(",")})',or the number of arguments are incorrect")
 
     }
   }
+ /*
+  {
+                          if (apply(e2,t,x)==0) {return throw new RuntimeException(s"Error: the denominator of the division '${Show.apply(e)}' is zero.")}
+                          else {return (apply(e1,t,x) / apply(e2,t,x))}
+                         }
+                         */
+  //println(s"Eval(SY): SyExprAll->${e} to ${res}")
+  res
+}
 
-  // Ignore variables or time arguments
+  // Ignore variables or time arguments 
   def apply(e:SyExprTime, t:Double): Double = apply(e,t,Map())
   def apply(e:SyExprVar, x:Valuation): Double = apply(e,0,x)
   def apply(e:SyExpr): Double = apply(e,0,Map())
 
-  def apply(v: Valuation): Point = v.view.mapValues(apply).toMap
+  def apply(v: Valuation): Point = v.view.mapValues(apply).toMap 
 
   def update(e:SyExprAll, t:SyExpr, v:Valuation): SyExpr =
     updInput(Eval.updTime(t,e),v)
@@ -83,23 +167,25 @@ object Eval {
   def update(phi:SySolution, t:SyExpr, v:Valuation): Valuation =
     updInput(v,Eval.updTime(t,phi))
 
+
   // variation for numerically computed solutions
   def updateNum(phi: Solution, t: SyExpr, v: Valuation): Valuation =
     phi.view.mapValues(updater => SVal(updater(apply(t))(apply(v)))).toMap
-    //updInput(v, Eval.updTime(t, phi))
+   
 
+
+    
   /** Update an expression by replacing initial values v(0)
     * @param e expression to be updated
     * @param sol solution with the new values
     * @return updated expression
     */
   def updInputFun(e:SyExprAll, sol:Valuation): SyExprTime = e match {
-//    case SFun(v, List(SVal(0.0))) if sol contains v  => sol(v)
-    case s:SVar                                      => sol(s.v)
-    //
+    case s:SVar => sol(s.v)
     case s:SFun[SymbolicExpr.All] =>
       SFun[SymbolicExpr.Time](s.f,s.args.map(e2 =>  updInputFun(e2,sol)))
     case SDiv(e1, e2)  => SDiv( updInputFun(e1,sol),updInputFun(e2,sol))
+    case SRes(e1, e2)  => SRes( updInputFun(e1,sol),updInputFun(e2,sol))
     case SMult(e1, e2) => SMult(updInputFun(e1,sol),updInputFun(e2,sol))
     case SPow(e1, e2)  => SPow( updInputFun(e1,sol),updInputFun(e2,sol))
     case SAdd(e1, e2)  => SAdd( updInputFun(e1,sol),updInputFun(e2,sol))
@@ -110,7 +196,7 @@ object Eval {
 
   def updInput(e:SyExprVar, sol:Valuation): SyExpr = updInputFun(e,sol) match {
     case t:SyExpr @unchecked => t // guaranteed to succeed (but type eliminated by erasure)
-    case v => throw new RuntimeException(s"updating variable in ${Show(e)} does nt yield an SExpr (${Show(v)}).")
+    case v => throw new RuntimeException(s"updating variable in ${Show(e)} does not yield an SExpr (${Show(v)}).")
   }
 
   def updTime(t:SyExpr, phi:SySolution): SySolutionVar =
@@ -124,32 +210,15 @@ object Eval {
 
   def updTime(newt: SyExprVar, expr: SyExprAll): SyExprVar = updTimeFun(newt, expr) match {
     case e: SyExprVar @unchecked => e  // guaranteed to succeed (but type eliminated by erasure)
-    case v => throw new RuntimeException(s"updating time in ${Show(expr)} does nt yield an SExprV (${Show(v)}).")
-//    case _:SArg => newt
-//    //
-//    case sf:SFun[SageExpr.All]  => SFun(sf.f,sf.args.map((e2:SExprFun) => updTime(newt,e2)))
-//    case SDiv(e1, e2)  => SDiv( updTime(newt,e1), updTime(newt,e2))
-//    case SMult(e1, e2) => SMult(updTime(newt,e1), updTime(newt,e2))
-//    case SPow(e1, e2)  => SPow( updTime(newt,e1), updTime(newt,e2))
-//    case SAdd(e1, e2)  => SAdd( updTime(newt,e1), updTime(newt,e2))
-//    case SSub(e1, e2)  => SSub( updTime(newt,e1), updTime(newt,e2))
-//    case e:SVal => e
-//    case e:SVar => e
+    case v => throw new RuntimeException(s"updating time in ${Show(expr)} does not yield an SExprV (${Show(v)}).")
   }
-//  def updTimeV(newt: SyExprTime, expr: SyExprVar): SyExprVar = updTimeFun(newt, expr) match {
-//    case e: SyExprVar => e
-//    case v => throw new RuntimeException(s"updating time in ${Show(expr)} does nt yield an SExprV (${Show(v)}).")
-//  }
-//  def updTimeT(newt: SyExprTime, expr: SyExprTime): SyExprTime = updTimeFun(newt, expr) match {
-//    case e: SyExprTime => e
-//    case v => throw new RuntimeException(s"updating time in ${Show(expr)} does not yield an SExprT (${Show(v)}).")
-//  }
+
   def updTimeFun(newt: SyExprAll, expr:SyExprAll): SyExprAll = expr match {
     case _:SArg => newt
-    //
     case sf:SFun[SymbolicExpr.All]  =>
       SFun(sf.f,sf.args.map((e2:SyExprAll) => updTimeFun(newt,e2)))
     case SDiv(e1, e2)  => SDiv( updTimeFun(newt,e1), updTimeFun(newt,e2))
+    case SRes(e1, e2)  => SRes( updTimeFun(newt,e1), updTimeFun(newt,e2))
     case SMult(e1, e2) => SMult(updTimeFun(newt,e1), updTimeFun(newt,e2))
     case SPow(e1, e2)  => SPow( updTimeFun(newt,e1), updTimeFun(newt,e2))
     case SAdd(e1, e2)  => SAdd( updTimeFun(newt,e1), updTimeFun(newt,e2))
@@ -158,60 +227,47 @@ object Eval {
     case e:SVar => e
   }
 
-  // replace variables by their expression in programs
-//  def updInput(syntax:Syntax,x:Valuation): Syntax = syntax match {
-//    case Atomic(as, de) => Atomic(as.map(a=>Assign(a.v,updInput(a.e,x))), updInput(de,x))
-//    case Seq(p, q) => Seq(updInput(p,x),updInput(q,x))
-//    case ITE(ifP, thenP, elseP) => ITE(updInput(ifP,x),updInput(thenP,x),updInput(elseP,x))
-//    case While(pre, d, doP) => While(updInput(pre,x),updInput(d,x),updInput(doP,x))
-//  }
-
-  // replace variables by their expression in boolean conditions
-//  def updInput(cond: Cond, x: Valuation) : Cond = cond match {
-//    case BVal(b) => cond
-//    case And(c1, c2) => And(updInput(c1,x),updInput(c2,x))
-//    case Or(c1, c2) => Or(updInput(c1,x),updInput(c2,x))
-//    case Not(c) => Not(updInput(c,x))
-//    case EQ(l1, l2) => EQ(updInput(l1,x),updInput(l2,x))
-//    case GT(l1, l2) => GT(updInput(l1,x),updInput(l2,x))
-//    case LT(l1, l2) => LT(updInput(l1,x),updInput(l2,x))
-//    case GE(l1, l2) => GE(updInput(l1,x),updInput(l2,x))
-//    case LE(l1, l2) => LE(updInput(l1,x),updInput(l2,x))
-//  }
-
-//  def updInput(lin: Lin, x: Valuation): Lin = lin match {
-//    case Var(v) => x.get(v) match {
-//      case Some(e) => syExpToLin(e)
-//      case None => lin
-//    }
-//    case Value(_) => lin
-//    case Add(l1, l2) => Add(updInput(l1,x),updInput(l2,x))
-//    case Mult(v, l) => Mult(v,updInput(l,x))
-//  }
-
-//  def syExpToLin(expr: SyExpr): Lin = expr match {
-//    case SVal(v) => Var(v)
-//  }
-
+  
+/*
   def lin2sage(l:Lin): SyExprVar = l match {
     case Var(v) => SVar(v) //SFun(v,List(SVal(0))) //SVar(v)
     case Value(v) => SVal(v)
     case Add(l1, l2) => SAdd(lin2sage(l1),lin2sage(l2))
-    case Mult(v, l2) => SMult(SVal(v.v),lin2sage(l2))
+    case Mult(l1, l2) => SMult(lin2sage(l1),lin2sage(l2)) //new
+
+
   }
+  */
+
+  
 
-  //def syExprToLin(e:SyExpr): Lin =
 
+ // New
+  def notlin2sage(l:NotLin): SyExprVar = l match {
+    case VarNotLin(v) => SVar(v) //SFun(v,List(SVal(0))) //SVar(v)
+    case ValueNotLin(v) => SVal(v)
+    case AddNotLin(l1, l2) => SAdd(notlin2sage(l1),notlin2sage(l2))
+    case MultNotLin(l1, l2) => SMult(notlin2sage(l1),notlin2sage(l2))
+    case DivNotLin(l1, l2) => SDiv(notlin2sage(l1),notlin2sage(l2))
+    case PowNotLin(l1,l2) => SPow(notlin2sage(l1),notlin2sage(l2))
+    case FuncNotLin(s,list)=>SFun(s,list.map((l:NotLin) => notlin2sage(l)))
+    case ResNotLin(l1,l2) => SRes(notlin2sage(l1),notlin2sage(l2)) 
 
+  }
+
+
+//NEWWWW
   def sFunToSVar(e: SyExprVar): SyExprVar = e match {
     case _:SVal => e
     case _:SArg => e
-    case _:SVar => e
-//    case sf:SFun[_] => SVar(sf.f): SymbolicExpr[SymbolicExpr.Var]
+    case SVar(_) => e
+    case SFun("_e", List(SVal(0))) => SVar("e")
+    case SFun("_pi", List(SVal(0))) => SVar("pi")
     case SFun(f, List(SVal(0))) => SVar(f)
     case SFun(f,a) =>
       error(s"Trying to calculate the value of an expression with a function $f(${a.map(Show(_)).mkString(",")}")
     case SDiv(e1, e2) => SDiv(sFunToSVar(e1),sFunToSVar(e2))
+    case SRes(e1, e2) => SRes(sFunToSVar(e1),sFunToSVar(e2))
     case SMult(e1, e2) => SMult(sFunToSVar(e1),sFunToSVar(e2))
     case SPow(e1, e2) => SPow(sFunToSVar(e1),sFunToSVar(e2))
     case SAdd(e1, e2) => SAdd(sFunToSVar(e1),sFunToSVar(e2))
@@ -233,6 +289,13 @@ object Eval {
       case (SVal(x),SVal(y)) => SVal(x/y)
       case (x,y) => SDiv(x,y)
     }
+    case SRes(e1, e2) => (simplifyMan(e1),simplifyMan(e2)) match {
+      case (x,SVal(1)) => SVal(0)
+      case (SVal(1),_) => SVal(1)
+      case (SVal(0),_) => SVal(0)
+      case (SVal(x),SVal(y)) => SVal(x%y)
+      case (x,y) => SRes(x,y)
+    }
     case SMult(e1, e2) => (simplifyMan(e1),simplifyMan(e2)) match {
       case (x,SVal(1)) => x
       case (SVal(1),x) => x
diff --git a/src/main/scala/hprog/frontend/Traj.scala b/src/main/scala/hprog/frontend/Traj.scala
old mode 100644
new mode 100755
index 28c5af0..b324b63
--- a/src/main/scala/hprog/frontend/Traj.scala
+++ b/src/main/scala/hprog/frontend/Traj.scala
@@ -3,21 +3,23 @@ package hprog.frontend
 import hprog.ast
 import hprog.ast.SymbolicExpr.{Pure, SyExpr}
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.common.TimeOutOfBoundsException
 import hprog.frontend.CommonTypes.{Point, SySolution, Valuation, Warnings, Solution}
 import hprog.frontend.Traj._
-import hprog.frontend.solver.Solver
+import hprog.frontend.solver._
+
 
 import scala.collection.mutable
 
+
 class Traj(syntax:Syntax, solver:Solver, dev: Deviator, bounds:(Double,Int)) {
 
   def eval(t:Double): Option[Point] =
     eval(SVal(t)).map(e => Eval(e._1))
 
   def eval(t:SyExpr,logger: Logger = new Logger()): Option[(Valuation,TimeClosure)] = {
-//    val logger = new Logger()
     Traj.run(Time(t), syntax, Map())(solver, dev, logger) match {
       case RFound(x,tc) => Some(x,tc)
       case RInf =>
@@ -37,29 +39,22 @@ class Traj(syntax:Syntax, solver:Solver, dev: Deviator, bounds:(Double,Int)) {
     }
   }
 
-//  def evalBatch(times:List[SyExpr]): List[(SyExpr,Valuation)] = {
+
   def evalBatch(from:SyExpr, to:SyExpr, step:SyExpr): List[(SyExpr,Valuation)] = {
 
     val fromv = Eval(from)
     val tov = Eval(solver.solveSymbExpr(to))
     val stepv = Eval(solver.solveSymbExpr(step))
-//    if(times.isEmpty) return Nil
     if (fromv > tov) return Nil
 
     val logger = new Logger()
-    //val times2 = times.map(solver.solveSymbExpr)
-    //        println("batch: "+times2.mkString(","))
     Traj.run(Times(fromv,tov,stepv), syntax, Map())(solver, dev, logger) match {
       case RFoundMany(found) => found
       case REnd(_, _,found) =>
-        //            println("REnd")
-        // Nil
-              found // but there may still missing times
+              found 
       case Traj.RInf =>
-        //            println("Inf")
         Nil
       case RFound(_,_) =>
-        //            println("##"+RFound(x))
         Nil
     }
   }
@@ -75,20 +70,6 @@ class Traj(syntax:Syntax, solver:Solver, dev: Deviator, bounds:(Double,Int)) {
     Traj.debug(()=>"run: "+rn)
     Traj.debug(()=>"dur: "+logger.time)
 
-//    val max: Double = rn match {
-//      case REnd(at, x, found) => Eval(logger.time)
-//      case _ => 10
-//    }
-//    val samples = if ((max)<=0)
-//      List(SVal(0))
-//    else
-//      SVal(0) :: (1 to 9).toList.map(_=> SDiv(SSub(SVal(max),SVal(0)),SVal(10)))
-//
-//    // add values of the trace (line) of thr traj
-//    println(" ## samples "+samples.mkString(","))
-//    val sampleValues = evalBatch(samples)
-//    println(" ## values: "+sampleValues.mkString(", "))
-
     rn
   }
   private lazy val logger = new Logger() // to be used by "fullRun" and friends
@@ -107,7 +88,6 @@ class Traj(syntax:Syntax, solver:Solver, dev: Deviator, bounds:(Double,Int)) {
   }
 
   def doFullRun: Unit = {
-//    bounds = Bound(b._2,b._1)
     afterFullRun(()=>())
   }
 
@@ -126,7 +106,7 @@ class Traj(syntax:Syntax, solver:Solver, dev: Deviator, bounds:(Double,Int)) {
 
 
   lazy val getVars: Set[String] =
-    Utils.getFstDeclVars(syntax)
+    Utils.getFstDeclVarsTHEN(syntax) //new
 }
 
 
@@ -139,8 +119,13 @@ object Traj {
       case _ => true
     }
   }
+
   case class Time(t:SyExpr)             extends RunTarget
+
+
   case class Times(from:Double,to:Double,step:Double)  extends RunTarget
+
+
   case class Bound(n:Int, timer:SyExpr)  extends RunTarget
 
   sealed abstract class Run {
@@ -150,10 +135,17 @@ object Traj {
       case run => run
     }
   }
+
+  
+
   case object RInf                                  extends Run
-  case class REnd(at: RunTarget, x: Valuation,
-                  found:List[(SyExpr,Valuation)])   extends Run
+
+  
+  case class REnd(at: RunTarget, x: Valuation,found:List[(SyExpr,Valuation)])   extends Run
+
   case class RFound(x: Valuation,tc:TimeClosure)    extends Run
+
+
   case class RFoundMany(found:List[(SyExpr,Valuation)])    extends Run
 
   case class TimeClosure(e:SySolution, t:SyExpr)
@@ -193,14 +185,16 @@ object Traj {
     * @param logger to remember the time that passed, boundary points, notes, and warnings.
     * @return a Run: a point found, the end of the program, or an infinite run.
     */
+
   def run(r: RunTarget, syntax: Syntax, x: Valuation)
          (implicit solver: Solver, dev: Deviator, logger: Logger)
   : Run = {
-    val res = syntax match { //(TimeOrBound, Syntax, Valuation) = syntax match {
+    
+      val res = syntax match { //(TimeOrBound, Syntax, Valuation) = syntax match {
       // Rule Atom: atomic case - stop evolving and evaluate
       case a@Atomic(_, _) => runAtomicUntilEnd(r, a, x) //(r,syntax,x)
       // Rule Seq: evolve first part (non-atomic) of at sequence
-      case ast.Seq(p, q) =>
+      case ast.Syntax.Seq(p, q) =>
         runSeq(r, p, q, x)
       // Rule ITE 1 and 2
       case ITE(ifP, thenP, elseP) =>
@@ -209,7 +203,6 @@ object Traj {
       case While(pre, d, doP) =>
         runWhile(r, pre, d, doP, x)
     }
-//    println(s"<<< got ${res}")
     res
   }
 
@@ -251,13 +244,11 @@ object Traj {
       // Rule While-2
       case preAtomic: Atomic =>
         b match {
-          // counter for "repeat" instructions
           case Counter(0) => run(r, pre, x)
-          case Counter(i) => run(r, ast.Seq(pre, While(q, Counter(i - 1), q)), x)
+          case Counter(i) => run(r,ast.Syntax.Seq(pre, While(q, Counter(i - 1), q)), x)
           // guards for traditional while loops
           case Guard(c) =>
             runAtomicUntilEnd(r, preAtomic, x) match {
-//              case RFound(t2, x2) =>
               case REnd(r2,x2,found2) =>
                 r2 match {
                   case Bound(z,till) if z <= 0 => // no need to check for "till" - it will set "z" to zero if finished
@@ -270,7 +261,6 @@ object Traj {
               case run => run
             }
         }
-      // Rule While-1
       case _ =>
         run(r, pre, x) match {
           case REnd(r2, x2, found) =>
@@ -284,14 +274,14 @@ object Traj {
   ////////////////////////////////////////////////////////////////////////
 
 
-  // Function that calls the solver
+  // Function that calls the solver and calculate de Atomic
   @scala.annotation.tailrec
   private def runAtomicUntilEnd(rb: RunTarget, at: Atomic, x: Valuation)
                                (implicit solver: Solver, logger: Logger)
   : Run = {
     at.de.dur match {
       // special case: (0 duration - log 0-time event (if some valuation))
-      case For(Value(0)) =>
+      case For(ValueNotLin(0)) =>
         val delta = Utils.toValuation(at.as,x)
         val x2 = x++delta
         if (delta.nonEmpty) logger.init(x2)
@@ -322,35 +312,44 @@ object Traj {
         val durEstimation = Solver.estimateDur(u, at.de.eqs, x2, solver) match {
           case Some((d,ws)) =>
             for (w<-ws) logger.warn(w,SVal(d))
-            For(Value(d))
+            For(ValueNotLin(d))
           case None => Forever
         }
         runAtomicUntilEnd(rb, Atomic(at.as, DiffEqs(at.de.eqs, durEstimation)), x)
     }
   }
 
-
-  private def runAtomicWithTime(time: SyExpr, at:Atomic, dur:Lin, x:Valuation,log:Boolean = false)
+  //Calculate Atomic with time
+  private def runAtomicWithTime(time: SyExpr, at:Atomic, dur:NotLin, x:Valuation,log:Boolean = false)
                                (implicit solver:Solver, logger: Logger): Run = {
-    val phi = solver.solveSymb(at.de.eqs) // try to solve sybmolically
+    
+    var extractVDE=Utils.extractVarsDifEqs(at) //Extracting the continuous variables from a diff.eq.
+    var updateValuate= x ++ Utils.toValuation(at.as,x) // Update x
+    var valToPoint=Eval.apply(updateValuate) // Convert x to Point type
+    var newListDiffEq=(at.de.eqs).map(e=>Eval.updateDiffEq(e,valToPoint,extractVDE)).toList //Change the differential equations of the atomic so that the constant variables become the respective double
+    var updateAtomic:Atomic=Atomic(at.as,DiffEqs(newListDiffEq,at.de.dur)) // Create the new Atomic
+    
+    println("AQUIIIIIIII")
+    val phi = solver.solveSymb(updateAtomic.de.eqs) // try to solve sybmolically
+    println("phi:",phi)
     val phiBkp:Solution = if (phi.isEmpty) solver.evalFun(at.de.eqs) else Map() // evaluate numerically if symbolic solver fails
     val x2 = x ++ Utils.toValuation(at.as,x) // update x with as
 
     debug(()=>s"running $at @ ${Eval(time)} (${Show(time)}) for $dur on $x2.")
     val realTime = Eval(time)
-    val durSy = Eval.lin2sage(dur)
+    val durSy = Eval.notlin2sage(dur)
     val durSy2 = Eval.updInput(durSy,x2)
     val durVal = solver.solveSymbExpr(SFun("max",List(SVal(0),durSy2))) //Eval(durSy2) max 0
     debug(()=>s"duration: $dur ~~> $durSy ~~> $durSy2 ~~> $durVal.")
 
     // Rule Atom-1 (time < dur)
-    if (realTime < Eval(durVal)) {
+     if (realTime < Eval(durVal)) {
       if (phi.nonEmpty) {
         val x3 = x2 ++ Eval.update(phi, time, x2) // update x with phi @ given time
         val tc = Eval.updInputFun(x2, phi) // replace in phi the variables in x2 (before diff eqs)
           .view.mapValues(solver.solveSymb).toMap // simplify/solve result
         //if (log) logger += time
-        val x4 = x3.view.mapValues(solver.solveSymbExpr).toMap
+         val x4 = x3.view.mapValues(solver.solveSymbExpr).toMap
         debug(()=> s"simplified updated state: $x4" )
         RFound(x4, TimeClosure(tc, time))
       } else {
@@ -373,6 +372,8 @@ object Traj {
         REnd(Time(r2), x3, Nil)
       }
     }
+
+
   }
 
 
@@ -384,18 +385,15 @@ object Traj {
   //////////////////////////////////////////////////////////////////
 
   @scala.annotation.tailrec
-  private def runAtomicWithTimes(times:Times, at:Atomic, durLin:Lin, x:Valuation,
+  private def runAtomicWithTimes(times:Times, at:Atomic, durLin:NotLin, x:Valuation,
                                  found:List[(SyExpr,Valuation)])
                                 (implicit  logger: Logger, solver: Solver): Run= {
     debug(()=>s"RunAtomicTimes @ ${Show(times)} - ${Show(at)} for ${Show(durLin)}")
     times match {
       case Times(from,to,_) if to<= (Eval(logger.time)+from) =>
-//      case Nil =>
         debug(()=>s"time to stop ($to > ${Eval(logger.time)+from})")
         RFoundMany(found)
-      //        REnd(times, x, found)
 
-//      case time::rest =>
       case Times(from,to,step) =>
         debug(()=>s"continuing")
         val time = from
@@ -404,15 +402,11 @@ object Traj {
             // time2 is the global time when the element was found.
             //val time2 = solver.solveSymbExpr(SAdd(logger.time, time))
             val realTime = SVal(Eval(logger.time) + time)
-            //println(s"found next @${Eval(time2)} -> ${Show(x2)}")
             val found2 = (realTime->x2) :: found
             val realNext = from + step
             debug(()=>s"atomc run found @ $time (real: $realTime, real next: $realNext)")
             if (realNext >= to)
-//            rest match {
-//              case Nil =>
                         RFoundMany(found2) //++ List(time2 -> x2)
-//              case hd :: tl =>
             else {
                 // rest2 updates the next time value to include the time spent to find x2
 //                val rest2 = solver.solveSymbExpr(SAdd(hd, time)) :: tl
@@ -430,22 +424,29 @@ object Traj {
   }
 
 
-  private def runAtomicWithBounds(b:Bound,at:Atomic,durLin:Lin,x:Valuation)
+  private def runAtomicWithBounds(b:Bound,at:Atomic,durLin:NotLin,x:Valuation)
                                  (implicit solver: Solver, logger: Logger): Run = {
-    val phi = solver.solveSymb(at.de.eqs) // try to solve sybmolically
+    
+
+
+    var extractVDE=Utils.extractVarsDifEqs(at) //Extracting the continuous variables from a diff.eq.
+    var updateValuate= x ++ Utils.toValuation(at.as,x) // Update x
+    var valToPoint=Eval.apply(updateValuate) // Convert x to Point type
+    var newListDiffEq=(at.de.eqs).map(e=>Eval.updateDiffEq(e,valToPoint,extractVDE)).toList //Change the differential equations of the atomic so that the constant variables become the respective double
+    var updateAtomic:Atomic=Atomic(at.as,DiffEqs(newListDiffEq,at.de.dur)) // Create the new Atomic
+  
+    println("AQUIIIIIIII")
+    val phi = solver.solveSymb(updateAtomic.de.eqs) 
+    //val phi = solver.solveSymb(at.de.eqs) // try to solve sybmolically
     val phiBkp: Solution = if (phi.isEmpty) solver.evalFun(at.de.eqs) else Map() // evaluate numerically if symbolic solver fails
     val x2 = x ++ Utils.toValuation(at.as,x) // update x with as
 
     logger.note(Show.pp(phi,x2))
 
     debug(()=>s"running $at bounded $b for $durLin on $x2.")
-    val durSy = Eval.lin2sage(durLin)
-    //debug(()=>s" - $durSy")
+    val durSy = Eval.notlin2sage(durLin)
     val durSy2 = Eval.updInput(durSy,x2)
-    //debug(()=>s" - $durSy2")
     val durValue = solver.solveSymbExpr( SFun("max",List(SVal(0),durSy2)))
-    //     val durVal = solver.solveSymbExpr(SFun("max",List(SVal(0),durSy2)))
-
     // manually comparing values that should be simplified already
     val stop = Eval(durValue) >= Eval(b.timer)
 
@@ -472,17 +473,6 @@ object Traj {
       REnd(Bound(b.n,newTimer),x3,Nil)
     }
 
-
-//    val durMin = Eval(durSy2) max 0
-//    debug(()=>s" - $durMin")
-//    val dur = durMin min b.timer
-//    debug(()=>s" - $dur")
-
-//    val x3 = x2++ solver.solveSymb(Eval.update(phi, SVal(dur), x2)) // update x with phi
-//    logger.init(x2)
-//    logger += SVal(dur)
-//    logger.end(x3)
-//    REnd(Bound(b.n,b.SSub(timer,dur)), x3, Nil)
   }
 
   // AUxiliar function to log warnings and notes
@@ -509,10 +499,9 @@ object Traj {
     }
   }
 
-  private val skip = Atomic(Nil, DiffEqs(Nil, For(Value(0))))
+  private val skip = Atomic(Nil, DiffEqs(Nil, For(ValueNotLin(0))))
 
   private def debug(str: () => String): Unit = {
-    // println("[Traj] "+str())
   }
 
 
diff --git a/src/main/scala/hprog/frontend/TrajOld.scala b/src/main/scala/hprog/frontend/TrajOld.scala
old mode 100644
new mode 100755
diff --git a/src/main/scala/hprog/frontend/TypeCheck.scala b/src/main/scala/hprog/frontend/TypeCheck.scala
index 1ee61e7..73bf71b 100755
--- a/src/main/scala/hprog/frontend/TypeCheck.scala
+++ b/src/main/scala/hprog/frontend/TypeCheck.scala
@@ -1,6 +1,7 @@
 package hprog.frontend
 
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.common.TypeCheckException
 
@@ -14,41 +15,12 @@ object TypeCheck {
       else Result(Some(errors.getOrElse(Nil) ++ other.errors.getOrElse(Nil)))
   }
 
-  //  def seq[A](f:(A,A)=>A)(x:Result[A],y:Result[A]): Result[A] = (x,y) match {
-  //    case (Left(m1),Left(m2)) => Left(m1++m2)
-  //    case (Left(m1),_) => Left(m1)
-  //    case (Right(a),Right(b)) => Right(f(a,b))
-  //  }
-  //  def seqUnit(x:Result[Unit],y:Result[Unit]): Result[Unit] = seq((_,_)=>())(x,y)
-
-//  def findProblems(f:Syntax=>Result, prog:Syntax): Result =
-//    f(prog) ++
-//      (prog match {
-//        //        case Assign(v, e) => Result(None)
-//        //        case DiffEqs(eqs, dur) => Result(None)
-//        case Seq(ps) => ps.map(findProblems(f,_)).foldRight(Result(None))(_++_)
-//        //        case Skip => Result(None)
-//        case ITE(_, thenP, elseP) => findProblems(f,thenP) ++ findProblems(f,elseP)
-//        case While(_, doP) => findProblems(f,doP)
-//        case _ => Result(None)
-//      })
 
   def isDur(c:Cond): Boolean = c match {
     case And(c1, c2) => isDur(c1) && isDur(c2)
     case Or(c1, c2) => isDur(c1) && isDur(c2)
-    //    case BVal(b) => false
-    //    case Not(c) => false
     case EQ(v, l) => true
-    //    case GT(v, l) => false
-    //    case LT(v, l) => false
-    //    case GE(v, l) => false
-    //    case LE(v, l) => false
     case _ => false
   }
 
-//  def validDur(prog: Syntax): Result = findProblems({
-//    case DiffEqs(_,Until(cond)) if !isDur(cond) => Result(Some(List(s"invalid duration condition: ${Show(cond)}")))
-//    case _ => Result(None)
-//  },prog
-//  )
 }
diff --git a/src/main/scala/hprog/frontend/Utils.scala b/src/main/scala/hprog/frontend/Utils.scala
old mode 100644
new mode 100755
index 43f206a..56812c7
--- a/src/main/scala/hprog/frontend/Utils.scala
+++ b/src/main/scala/hprog/frontend/Utils.scala
@@ -2,40 +2,487 @@ package hprog.frontend
 
 import hprog.ast.SymbolicExpr.{SyExpr, SyExprAll, SyExprVar}
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.frontend.CommonTypes.Valuation
+import scala.math._
+import scala.util.control.Breaks._
+
+
+
+// Scrip with auxiliar functions 
+
+
 
 object Utils {
 
-//  def replaceVar(by:String=>String,e:Lin): Lin = e match {
-//    case Var(v) => Var(by(v))
-//    case Value(v) => e
-//    case Add(l1, l2) => Add(replaceVar(by,l1),replaceVar(by,l2))
-//    case Mult(v, l) => Mult(v,replaceVar(by,l))
-//  }
+  /////////////////////////////////////////////////////////////////////////////////////////////////////
 
+  // take content of type syntax and return content of type List[List[DiffEq]]
+  // Basically what this function does is to remove all differential equations from a program
   def getDiffEqs(prog:Syntax): List[List[DiffEq]]  = prog match {
     case Atomic(_, DiffEqs(eqs,_)) => List(eqs)
-    case Seq(p, q) => getDiffEqs(p) ::: getDiffEqs(q)
+    case Seq(p, q) => getDiffEqs(p) ::: getDiffEqs(q) // joins the two lists
     case ITE(_, thenP, elseP) => getDiffEqs(thenP) ::: getDiffEqs(elseP)
     case While(pre, _, doP) => getDiffEqs(pre) ::: getDiffEqs(doP)
   }
 
-//    prog match {
-//    case d@DiffEqs(eqs, _) => List(eqs)
-//    case hprog.ast.Seq(p :: ps) =>
-//      getDiffEqs(p) ::: getDiffEqs(hprog.ast.Seq(ps))
-//    case ITE(_, thenP, elseP) =>
-//      getDiffEqs(thenP) ++ getDiffEqs(elseP)
-//    case While(c, doP) => getDiffEqs(doP)
-//    case _ => Nil // Seq(Nil) and Skip
-//  }
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+// New
+def extractAssigments(prog:Syntax):List[Assign] = prog match {
+  
+  case Atomic(as,_) => {
+  	return as
+  }
+  case Seq(Atomic(as,_),q) => {
+  	var ac=as++extractAssigments(q)
+  	return ac
+  }
+  case Seq(While(pre,c,p),q) => {
+    var ac=extractAssigments(pre)
+    return ac
+  }
+  //case Seq(p,q) =>{
+  
+  // return extractAssigments(p) ++ extractAssigments(q)
+  //}
+  case While(pre,c,p) => {
+  	return extractAssigments(pre)
+  
+  }
+  case Seq(p,q) =>{
+  
+   return extractAssigments(p) ++ extractAssigments(q)
+  }
+  case _ =>  List()
+
+
+}
+
+
+// New
+// Function with de responsability to extract a list of lists of  differential equations
+def extractDifEqs(prog:Syntax):List[List[DiffEq]] = prog match {
+  
+  case Atomic(as,de) => {
+    return List(de.eqs)
+  }
+  case Seq(Atomic(as,de),q) => {
+    var ac=List(de.eqs)++extractDifEqs(q)
+    return ac
+  }
+  case Seq(p,q) =>{
+  
+   return extractDifEqs(p) ++ extractDifEqs(q)
+  }
+  case While(pre,c,p) => {
+    return extractDifEqs(pre) ++ extractDifEqs(p)
+  
+  }
+  case ITE(ifP,thenP,elseP) =>  {
+    return extractDifEqs(thenP) ++ extractDifEqs(elseP)
+  }
+
+}
+
+// New
+// Function with the responsibility to extract de variables of the differential equations
+def extractVarsDifEqs(prog:Syntax):List[List[String]] = {
+  var eqsdiff=extractDifEqs(prog)
+  var listVars:List[List[String]]=List()
+
+  for (lsteqDiff <- eqsdiff){
+    var aux:List[String]=List()
+    for (eqDiff <- lsteqDiff){
+      aux=aux ++ List((eqDiff.v).v)
+      //println("eqDiff:"+(eqDiff.v).v)
+      //println("aux:"+aux)
+    }
+    listVars=listVars ++ List(aux)
+
+  }
+
+  return listVars
+}
+
+def extractVarsDifEqs(prog:Atomic):List[String] = {
+  
+  var listVars:List[String]=List()
+
+  for (eqDiff <- prog.de.eqs){
+    //var aux:List[String]=List()
+      var aux:String=eqDiff.v.v
+      listVars=listVars ++ List(aux)
+      //println("eqDiff:"+(eqDiff.v).v)
+      //println("aux:"+aux)   
+
+  }
+
+  return listVars
+}
+//def extractDeclarationSyntax(prog:Assign):Map[String,NotLin]={}
+
+//This function converts the Syntax coming from the Parser, into a Syntax where the parsing of the constant variables becomes the parsing of the linear expression that defines it
+def updateSyntax(prog:Syntax,varsDcl:Map[String,NotLin],iteration:Int,varsDifEqs:List[List[String]],control:Int):(Syntax,Map[String,NotLin],Int)={
+ prog match {
+  case Atomic(as,de) => {
+    var listAcum:List[Assign]=List()
+   // var aux:(Assign,Map[String,NotLin])=updateSyntax(as(0),varsDcl,iteration,varsDifEqs,0)
+    var aux1:Map[String,NotLin]=varsDcl
+    //listAcum=listAcum ++ aux(0)
+
+    for (a<-as){
+       var aux= updateSyntax(a,aux1,iteration,varsDifEqs,0)
+       listAcum=listAcum ::: aux._1 :: Nil
+       aux1=aux._2
+    }
+    var auxDe=updateSyntax(de,aux1,iteration + 1,varsDifEqs,1)
+    return (Atomic(listAcum,auxDe._1),auxDe._2,iteration+1)
+  }
+  case Seq(p,q) =>{
+    var auxP=updateSyntax(p,varsDcl,iteration,varsDifEqs,0)
+    var auxQ=updateSyntax(q,auxP._2,auxP._3,varsDifEqs,0)
+   return (Seq(auxP._1,auxQ._1),auxQ._2,auxQ._3)
+  }
+  case While(pre,c,p) => {
+    var auxPre=updateSyntax(pre,varsDcl,iteration,varsDifEqs,0)
+    var auxP=updateSyntax(p,auxPre._2,auxPre._3,varsDifEqs,0)
+    return (While(auxPre._1,c,auxP._1),auxP._2,auxP._3)
+  
+  }
+  case ITE(ifP,thenP,elseP) =>  {
+    var choice:Map[String,NotLin]=Map()
+    var auxifp=updateSyntax(ifP,varsDcl,iteration,varsDifEqs,0)
+    var bol:Boolean=Eval.apply(Map(),auxifp._1)
+    var auxThenP=updateSyntax(thenP,varsDcl,iteration,varsDifEqs,0)
+    var auxElseP=updateSyntax(elseP,varsDcl,auxThenP._3,varsDifEqs,0)
+
+    if (bol) {
+      choice=auxThenP._2
+    } else {
+      choice=auxElseP._2
+    }
+    
+    return (ITE(ifP,auxThenP._1,auxElseP._1),choice,auxElseP._3)
+  }
+
+ }
+
+}
+
+def updateSyntax(prog:NotLin,varsDcl:Map[String,NotLin],iteration:Int,varsDifEqs:List[List[String]],control:Int):(NotLin,Map[String,NotLin],Int)={
+ prog match {
+  case VarNotLin(v)=> {
+    if (control==1) {
+        println("iteration:",iteration)
+        println("varsDifEqs:",varsDifEqs)
+        println("varsDifEqs(iteration-1).contains(v):",varsDifEqs(iteration-1).contains(v))
+        if (varsDifEqs(iteration-1).contains(v)) {
+            return (VarNotLin(v),varsDcl,iteration)
+        } else {
+          return (varsDcl(v),varsDcl,iteration)
+        }
+  } else {
+    return (varsDcl(v),varsDcl,iteration)
+  }
+}
+  case ValueNotLin(v) => {
+    return (ValueNotLin(v),varsDcl,iteration)
+  }
+  case AddNotLin(x,y)=> {
+    var auxX=updateSyntax(x,varsDcl,iteration,varsDifEqs,control)
+    var auxY=updateSyntax(y,varsDcl,iteration,varsDifEqs,control)
+    return (AddNotLin(auxX._1,auxY._1),varsDcl,iteration)
+  }
+  case MultNotLin(x,y)=> {
+    var auxX=updateSyntax(x,varsDcl,iteration,varsDifEqs,control)
+    var auxY=updateSyntax(y,varsDcl,iteration,varsDifEqs,control)
+    return (MultNotLin(auxX._1,auxY._1),varsDcl,iteration)
+  }
+  case DivNotLin(x,y)=> {
+    var auxX=updateSyntax(x,varsDcl,iteration,varsDifEqs,control)
+    var auxY=updateSyntax(y,varsDcl,iteration,varsDifEqs,control)
+    return (DivNotLin(auxX._1,auxY._1),varsDcl,iteration)
+    }
+  case ResNotLin(x,y)=> {
+    var auxX=updateSyntax(x,varsDcl,iteration,varsDifEqs,control)
+    var auxY=updateSyntax(y,varsDcl,iteration,varsDifEqs,control)
+    return (ResNotLin(auxX._1,auxY._1),varsDcl,iteration)
+  }
+  case PowNotLin(x,y)=> {
+    var auxX=updateSyntax(x,varsDcl,iteration,varsDifEqs,control)
+    var auxY=updateSyntax(y,varsDcl,iteration,varsDifEqs,control)
+    return (PowNotLin(auxX._1,auxY._1),varsDcl,iteration)
+  }
+  case FuncNotLin(s,xs)=> {
+    var listNotLin:List[NotLin]=List()
+    for(x<-xs){
+      var aux=updateSyntax(x,varsDcl,iteration,varsDifEqs,control)
+      listNotLin=listNotLin ::: aux._1 :: Nil
+    }
+    return (FuncNotLin(s,listNotLin),varsDcl,iteration)
+  }
+  }
+}
+
+
+def updateSyntax(prog:Assign,varsDcl:Map[String,NotLin],iteration:Int,varsDifEqs:List[List[String]],control:Int):(Assign,Map[String,NotLin],Int)={
+ prog match {
+  case Assign(v,e) => {
+    //println("old:",varsDcl)
+    var aux=updateSyntax(e,varsDcl,iteration,varsDifEqs,0)
+    var newvarsDcl=aux._2+(v.v->aux._1)
+    println("new:",newvarsDcl)
+    return (Assign(v,aux._1),newvarsDcl,iteration)
+  }
+}
+}
+
+def updateSyntax(prog:DiffEq,varsDcl:Map[String,NotLin],iteration:Int,varsDifEqs:List[List[String]],control:Int):(DiffEq,Map[String,NotLin],Int)={
+  prog match {
+  case DiffEq(v,e) => {
+    var aux=updateSyntax(e,varsDcl,iteration,varsDifEqs,1)
+    return (DiffEq(v,aux._1),aux._2,iteration)
+  }
+}
+}
+
+def updateSyntax(prog:DiffEqs,varsDcl:Map[String,NotLin],iteration:Int,varsDifEqs:List[List[String]],control:Int):(DiffEqs,Map[String,NotLin],Int)={
+ prog match {
+  case DiffEqs(eqs,dur) => {
+    var listDiffEq:List[DiffEq]=List()
+    //var aux=updateSyntax(eqs(0),varsDcl,iteration,varsDifEqs,1)
+    var aux1:Map[String,NotLin]=varsDcl
+    //listDiffEq=listDiffEq ++ aux(0)
+
+    for (e<-eqs){
+       var aux= updateSyntax(e,aux1,iteration,varsDifEqs,1)
+       listDiffEq=listDiffEq ::: aux._1 :: Nil
+       aux1=aux._2
+    }
+
+    return (DiffEqs(listDiffEq,dur),aux1,iteration)
+  }
+}
+}
+
+
+def updateSyntax(prog:Cond,varsDcl:Map[String,NotLin],iteration:Int,varsDifEqs:List[List[String]],control:Int):(Cond,Map[String,NotLin],Int)={
+ prog match {
+  case BVal(b)=> {
+   return (BVal(b),varsDcl,iteration)
+  }
+  case And(c1,c2)=> {
+    var auxC1=updateSyntax(c1,varsDcl,iteration,varsDifEqs,0)
+    var auxC2=updateSyntax(c2,auxC1._2,iteration,varsDifEqs,0)
+    return (And(auxC1._1,auxC2._1),auxC2._2,iteration)
+  }
+  case Or(c1,c2)=> {
+    var auxC1=updateSyntax(c1,varsDcl,iteration,varsDifEqs,0)
+    var auxC2=updateSyntax(c2,auxC1._2,iteration,varsDifEqs,0)
+    return (Or(auxC1._1,auxC2._1),auxC2._2,iteration)
+  }
+  case Not(c1)=> {
+    var auxC1=updateSyntax(c1,varsDcl,iteration,varsDifEqs,0)
+    return (Not(auxC1._1),auxC1._2,iteration)
+  }
+  case EQ(x1,x2)=> {
+    var auxX1=updateSyntax(x1,varsDcl,iteration,varsDifEqs,0)
+    var auxX2=updateSyntax(x2,auxX1._2,iteration,varsDifEqs,0)
+    return (EQ(auxX1._1,auxX2._1),auxX2._2,iteration)
+  }
+  case GT(x1,x2)=> {
+    var auxX1=updateSyntax(x1,varsDcl,iteration,varsDifEqs,0)
+    var auxX2=updateSyntax(x2,auxX1._2,iteration,varsDifEqs,0)
+    return (GT(auxX1._1,auxX2._1),auxX2._2,iteration)
+  }
+  case GE(x1,x2)=> {
+    var auxX1=updateSyntax(x1,varsDcl,iteration,varsDifEqs,0)
+    var auxX2=updateSyntax(x2,auxX1._2,iteration,varsDifEqs,0)
+    return (GE(auxX1._1,auxX2._1),auxX2._2,iteration)
+  }
+  case LT(x1,x2)=> {
+    var auxX1=updateSyntax(x1,varsDcl,iteration,varsDifEqs,0)
+    var auxX2=updateSyntax(x2,auxX1._2,iteration,varsDifEqs,0)
+    return (LT(auxX1._1,auxX2._1),auxX2._2,iteration)
+  }
+  case LE(x1,x2)=> {
+    var auxX1=updateSyntax(x1,varsDcl,iteration,varsDifEqs,0)
+    var auxX2=updateSyntax(x2,auxX1._2,iteration,varsDifEqs,0)
+    return (LE(auxX1._1,auxX2._1),auxX2._2,iteration)
+  }
+}
+}
+
+
+
+
+
+
+
+//New
+// This function verify if the linear expressions of the Eqs.Diffs are linears
+ def verifyLinearityEqsDiff(prog:Syntax):Option[List[DiffEq]] =  {
+   var diffeqs=extractDifEqs(prog) //List of List of Diff.eqs
+   var varsDifEqs=extractVarsDifEqs(prog) // extract de variables of the differential equations
+   //var varsDifEqs=getFstDeclVarsTHEN(prog) // set of declared variables NEWWW
+   var iteration=0
+   var aux=0
+
+   for (lsteqDiff <- diffeqs){
+    var aux=0
+    for (eqDiff <- lsteqDiff){
+     aux=extractVarsLinearExp(eqDiff.e,varsDifEqs(iteration)) // extract the number of variables in a linear expressions 
+     //println("aux:"+aux)
+     if (aux > 1 ) return Some(lsteqDiff)
+     }
+     iteration=iteration + 1
+  }
+  return None   
+ }
+ 
+
+ /*
+ // LINEAR EXPRESSIONS ONLY
+ // chamar sets em vez de listas
+ // New
+ // This function extract the number of variables in a linear expression of an Eq.Diff
+ def extractVarsLinearExp(lin:Lin,listOfVars:List[String]):Int = lin match {
+
+  case Value(value) =>  0
+  
+  case Var(v) => {
+   if (listOfVars.contains(v))  1 
+   else  0
+  }
+  case Add(l1,l2) => math.max(extractVarsLinearExp(l1,listOfVars),extractVarsLinearExp(l2,listOfVars))
+  
+  case Mult(l1,l2) => (extractVarsLinearExp(l1,listOfVars) + extractVarsLinearExp(l2,listOfVars))
+  
+
+ }
+
+*/
+
+// NON LINEAR EXPRESSIONS ONLY
+ // chamar sets em vez de listas
+ // New
+ // This function extract the number of variables in a linear expression of an Eq.Diff
+ def extractVarsLinearExp(notlin:NotLin,listOfVars:List[String]):Int = notlin match {
+
+  case ValueNotLin(value) =>  0
+  
+  case VarNotLin(v) => {
+   if (listOfVars.contains(v))  1 
+   else  0
+  }
+  case AddNotLin(l1,l2) => math.max(extractVarsLinearExp(l1,listOfVars),extractVarsLinearExp(l2,listOfVars))
+  
+  case MultNotLin(l1,l2) => (extractVarsLinearExp(l1,listOfVars) + extractVarsLinearExp(l2,listOfVars))
+  
+  case DivNotLin(l1,l2) => (extractVarsLinearExp(l1,listOfVars) + 1000*extractVarsLinearExp(l2,listOfVars)) //Only linear in the dividend, in the divisor it is always non-linear 
+
+  case ResNotLin(l1,l2) => (1000*extractVarsLinearExp(l1,listOfVars) + 1000*extractVarsLinearExp(l2,listOfVars)) // remainder never can be linear
+
+  case PowNotLin(l1,l2) => (1000*extractVarsLinearExp(l1,listOfVars) + 1000*extractVarsLinearExp(l2,listOfVars)) // pow never can be linear
+
+  case FuncNotLin(s,list) => funcextract(s,list,listOfVars)
+
+ }
+
+
+//new
+ def funcextract(s:String,list:List[NotLin],listOfVars:List[String]):Int = (s,list) match {
+  case ("PI",List()) => 0
+  case ("E",List()) => 0
+  case ("max",List(n1,n2)) => math.max(extractVarsLinearExp(n1,listOfVars),extractVarsLinearExp(n2,listOfVars))
+  case ("min",List(n1,n2)) => math.min(extractVarsLinearExp(n1,listOfVars),extractVarsLinearExp(n2,listOfVars))
+  // Any variables found in the following functions make the expression non-linear 
+  case ("exp",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("sin",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("cos",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("tan",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("arcsin",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("arccos",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("arctan",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("sinh",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("cosh",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("tanh",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("sqrt",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("log",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case ("log10",List(n)) => 1000*extractVarsLinearExp(n,listOfVars)
+  case (_,_) => throw new RuntimeException(s"Unknown function '${s}(${list.mkString(",")})', or the number of arguments are incorrect")
 
+  }
+
+////// New /////// 
+//verify if the free varibles had already been declarated before being used.
+  def assigmentsVerify(prog:Syntax): Set[String] = prog match {
+    
+    case Seq(p,q) => {
+      var as=extractAssigments(p) ++ extractAssigments(q)
+      var declVar= as.map(_.v.v).toList //list of declarated variables in atomic
+      var aux=0
+      var aux2=1
+      var zz:Set[String]=Set()
+      for (i <- as){
+ 
+        var z=getVars(i.e)   // Set of used variables in the atribution of other veriable in atomic
+        // remotion of existing variables in Z that have been declareted 
+        for (j <- 0 until (aux) by 1){
+          z -= declVar(j)
+        }
+        
+        zz=zz++z
+        aux=aux+1
+        
+        }
+       
+       return zz	
+    
+    }
+    case Atomic(as,_)=>{
+      var declVar= as.map(_.v.v).toList //list of declarated variables in atomic
+      var aux=0
+      var aux2=1
+      var zz:Set[String]=Set()
+      
+      for (i <- as){
+ 
+        var z=getVars(i.e)   // Set of used variables in the atribution of other veriable in atomic
+        // remotion of existing variables in Z that have been declareted 
+        for (j <- 0 until (aux) by 1){
+          z -= declVar(j)
+        }
+
+        // if Z stayed empty, it is because the variables had already been declareted, if not no        
+        
+        zz=zz++z
+        aux=aux+1
+        
+        }
+       
+       return zz
+    }   
+    case ITE(ifP,thenP,elseP) =>getVars(ifP)++assigmentsVerify(thenP)++assigmentsVerify(elseP) //probably this case does not have any effect because it is obligatory the declaration of variables above the instructions 
+    case While(pre,c,p) => assigmentsVerify(pre)  
+  }
+
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////
   /**
     * Collect the free variables, following the "free variable rules" (Lince paper)
     * @param prog where to search for the first free variables
     * @return the free variables of the first atomic expression
     */
+
+  // What this function does is to get p:=3+v and get Set(v), but it only cares about the first set of atomic
   def getFstFreeVars(prog:Syntax): Set[String] = prog match {
     case Atomic(as, _) => as.toSet.flatMap((a:Assign)=>getVars(a.e))
     case Seq(p, _) => getFstFreeVars(p)
@@ -43,60 +490,211 @@ object Utils {
     case While(pre, _, _) => getFstFreeVars(pre)
   }
 
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+
+
+// Verify if exists free variables  already been declarated before being used, and also if they are used variables that are not declareted
+// Verify if the linear expressions of the Eq.Diffs are linears
   def isClosed(prog:Syntax): Either[String,Unit] = {
-    val declVar = getFstDeclVars(prog)
-    val initFreeVars = getFstFreeVars(prog)
-    val usedVars = getUsedVars(prog)
-    if (initFreeVars.nonEmpty)
-      Left(s"Initial declaration has free variables: ${initFreeVars.mkString(", ")}")
-    else if (!usedVars.forall(declVar))
-      Left(s"Variable(s) not declared: ${(usedVars -- declVar).mkString(", ")}")
-    else
+    val declVarTHEN = getFstDeclVarsTHEN(prog) //make a set with the firsts declareted variables (THEN)
+     
+    val declVarELSE = getFstDeclVarsELSE(prog) //make a set with the firsts declareted variables (ELSE)
+    
+    val usedVarsTHEN = getUsedVarsTHEN(prog)   //make a set with the firsts used variables
+    
+    val usedVarsELSE = getUsedVarsELSE(prog)  //make a set with the firsts used variables
+    
+    val asVerify=assigmentsVerify(prog) //make a set of free variables that not had been declareted before of ther invocation.
+
+    val varsEqDiffVerify=verifyLinearityEqsDiff(prog)
+    //println("linear?:"+varsEqDiffVerify)
+
+
+    if (asVerify.nonEmpty) //Verify if exist free variables that not had been declareted before, if exist i print it.
+      Left(s"Initial declaration has free variables that were not declared: ${asVerify.mkString(", ")}")
+    else if (!usedVarsTHEN.forall(declVarTHEN)) 
+      Left(s"Variable(s) not declared: ${((usedVarsTHEN -- declVarTHEN)++(usedVarsELSE-- declVarELSE)).mkString(", ")}")
+    else if (!usedVarsELSE.forall(declVarELSE))
+       Left(s"Variable(s) not declared: ${((usedVarsTHEN -- declVarTHEN)++(usedVarsELSE-- declVarELSE)).mkString(", ")}")
+    else if (varsEqDiffVerify.nonEmpty)
+      Left(s"There are differential equations that are not linear: ${varsEqDiffVerify.get.map(Show.apply).mkString(", ")}")
+    else 
       Right(())
-//    val vars = getDeclVars(prog)
-//    val free = getFreeVars(prog)
-//    free.forall(f => vars contains f)
   }
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+  // take a list of differential equations and take the variables with the tilde on top! (ex: p'=1+x returns set(p))
   def getDefVars(eqs: List[DiffEq]): Set[String] =
     eqs.map(_.v.v).toSet
 
-  def getUsedVars(eqs: List[DiffEq]): Set[String] =
-    eqs.flatMap(eq => getVars(eq.e)).toSet
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+
+
+
+
+
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+//New
+  // The function getUsedVars is defined for List[DiffEq],Syntax,DiffEqs and Dur, returning the variables used there
+  def getUsedVarsTHEN(eqs: List[DiffEq]): Set[String] =
+    eqs.flatMap(eq => getVars(eq.e)+eq.v.v).toSet  // New
 
-  def getUsedVars(prog:Syntax): Set[String] = prog match {
-    case Atomic(as, de) => as.toSet.flatMap((a:Assign)=>getVars(a.e)+a.v.v) ++ getUsedVars(de)
-    case Seq(p, q) => getUsedVars(p) ++ getUsedVars(q)
-    case ITE(ifP, thenP, elseP) => getVars(ifP) ++ getUsedVars(thenP) ++ getUsedVars(elseP)
-    case While(pre, d, doP) => getUsedVars(pre) ++ getVars(d) ++ getUsedVars(doP)
+  def getUsedVarsTHEN(prog:Syntax): Set[String] = prog match {
+    case Atomic(as, de) => as.toSet.flatMap((a:Assign)=>getVars(a.e)+a.v.v) ++ getUsedVarsTHEN(de)
+    case Seq(p, q) => getUsedVarsTHEN(p) ++ getUsedVarsTHEN(q)
+    case ITE(ifP, thenP, _) => getVars(ifP) ++ getUsedVarsTHEN(thenP) 
+    case While(pre, d, doP) => getUsedVarsTHEN(pre) ++ getVars(d) ++ getUsedVarsTHEN(doP)
   }
 
-  def getUsedVars(eqs: DiffEqs): Set[String] =
-    getUsedVars(eqs.eqs) ++ getUsedVars(eqs.dur)
+  def getUsedVarsTHEN(eqs: DiffEqs): Set[String] =
+    getUsedVarsTHEN(eqs.eqs) ++ getUsedVarsTHEN(eqs.dur)
 
-  def getUsedVars(dur: Dur): Set[String] = dur match {
+  def getUsedVarsTHEN(dur: Dur): Set[String] = dur match {
     case Until(c,_,_) =>getVars(c)
+    case For(nl) => getVars(nl) //New  
     case _ => Set()
   }
 
-  @scala.annotation.tailrec
-  def getFstDeclVars(prog:Syntax): Set[String] = prog match {
-    case Atomic(a, _)     => a.map(_.v.v).toSet
-    case Seq(p, _)        => getFstDeclVars(p)
-    case ITE(_, thenP, _) => getFstDeclVars(thenP)
-    case While(pre, _, _) => getFstDeclVars(pre)
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+//New
+ def getUsedVarsELSE(eqs: List[DiffEq]): Set[String] =
+    eqs.flatMap(eq => getVars(eq.e)+eq.v.v).toSet  //New
+
+  def getUsedVarsELSE(prog:Syntax): Set[String] = prog match {
+    case Atomic(as, de) => as.toSet.flatMap((a:Assign)=>getVars(a.e)+a.v.v) ++ getUsedVarsELSE(de)
+    case Seq(p, q) => getUsedVarsELSE(p) ++ getUsedVarsELSE(q)
+    case ITE(ifP, _, elseP) => getVars(ifP) ++ getUsedVarsELSE(elseP)
+    case While(pre, d, doP) => getUsedVarsELSE(pre) ++ getVars(d) ++ getUsedVarsELSE(doP)
+  }
+
+  def getUsedVarsELSE(eqs: DiffEqs): Set[String] =
+    getUsedVarsELSE(eqs.eqs) ++ getUsedVarsELSE(eqs.dur)
+
+  def getUsedVarsELSE(dur: Dur): Set[String] = dur match {
+    case Until(c,_,_) =>getVars(c)
+    case For(nl) => getVars(nl) //New 
+    case _ => Set()
   }
 
+
+
+
+
+
+
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+// New
+  // Take a program and remove the first declared variables (from the first atomic)
+  //@scala.annotation.tailrec
+  def getFstDeclVarsTHEN(prog:Syntax): Set[String] = prog match {
+    
+    case Seq(p,q) => {
+      var as=extractAssigments(Seq(p,q))
+      var asSet=as.map(_.v.v).toSet
+      
+      return asSet
+      }
+    case Atomic(a, _)     => a.map(_.v.v).toSet // creates an set of the first variables declared
+   
+    
+      
+    case ITE(_, thenP, _) => getFstDeclVarsTHEN(thenP) 
+    
+    case While(pre, _, _) => getFstDeclVarsTHEN(pre)
+  }
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+//New
+  def getFstDeclVarsELSE(prog:Syntax): Set[String] = prog match {
+    case Atomic(a, _)     => a.map(_.v.v).toSet // creates an set of the first variables declared
+   
+    case Seq(p,q) => {
+      var as=extractAssigments(p) ++ extractAssigments(q)
+      var asSet=as.map(_.v.v).toSet
+      return asSet
+      }
+    case ITE(_, _, elseP) =>getFstDeclVarsELSE(elseP) 
+    case While(pre, _, _) => getFstDeclVarsELSE(pre)
+  }
+
+
+
+
+
+
+
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// create sets with the variables used there
   def getVars(guard: LoopGuard): Set[String] = guard match {
     case Counter(_) => Set()
     case Guard(c) => getVars(c)
   }
 
+
+/*
+  //new
   def getVars(lin: Lin): Set[String] = lin match {
     case Var(v) => Set(v)
     case Value(_) => Set()
     case Add(l1, l2) => getVars(l1) ++ getVars(l2)
-    case Mult(_, l) => getVars(l)
+    case Mult(l1, l2) => getVars(l1) ++ getVars(l2)
+  }
+
+*/
+
+    // new
+  def getVars(notlin: NotLin): Set[String] = notlin match {
+    case VarNotLin(v) => Set(v)
+    case ValueNotLin(_) => Set()
+    case AddNotLin(l1, l2) => getVars(l1) ++ getVars(l2)
+    case MultNotLin(l1, l2) => getVars(l1) ++ getVars(l2)
+    case DivNotLin(l1,l2) => getVars(l1) ++ getVars(l2)
+    case ResNotLin(l1,l2) => getVars(l1) ++ getVars(l2)  
+    case PowNotLin(l1,l2) => getVars(l1) ++ getVars(l2)
+    case FuncNotLin(s,list) => getVarsAux(list)
+  }
+
+
+  def getVarsAux(list:List[NotLin]): Set[String] = list match {
+    case List() => Set()
+    case n::List() => getVars(n)
+    case n::ns => getVars(n) ++ getVarsAux(ns)
   }
 
   def getVars(cond: Cond): Set[String] = cond match {
@@ -109,25 +707,126 @@ object Utils {
     case LT(l1,l2)    => getVars(l1) ++ getVars(l2)
     case GE(l1,l2)    => getVars(l1) ++ getVars(l2)
     case LE(l1,l2)    => getVars(l1) ++ getVars(l2)
+    
   }
 
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
+
+
+
+
+///// New
+
+/////////////////////////////////////////////////////////////////////////////////
+
+// create lists with the variables used there
+  def getVarsList(guard: LoopGuard): List[String] = guard match {
+    case Counter(_) => List()
+    case Guard(c) => getVarsList(c)
+  }
+
+/*
+  // new
+  def getVarsList(lin: Lin): List[String] = lin match {
+    case Var(v) => List(v)
+    case Value(_) => List()
+    case Add(l1, l2) => getVarsList(l1) ++ getVarsList(l2)
+    case Mult(l1, l2) => getVarsList(l1) ++ getVarsList(l2)
+  }
+  */
+
+    // new
+  def getVarsList(notlin: NotLin): List[String] = notlin match {
+    case VarNotLin(v) => List(v)
+    case ValueNotLin(_) => List()
+    case AddNotLin(l1, l2) => getVarsList(l1) ++ getVarsList(l2)
+    case MultNotLin(l1, l2) => getVarsList(l1) ++ getVarsList(l2)
+    case DivNotLin(l1,l2) => getVarsList(l1) ++ getVarsList(l2)
+    case ResNotLin(l1,l2) => getVarsList(l1) ++ getVarsList(l2) 
+    case PowNotLin(l1,l2) => getVarsList(l1) ++ getVarsList(l2)
+    case FuncNotLin(s,list) => getVarsListAux(list)
+    
+  }
+
+  def getVarsListAux(list:List[NotLin]): List[String] = list match {
+    case List() => List()
+    case n::List() => getVarsList(n)
+    case n::ns => getVarsList(n) ++ getVarsListAux(ns)
+  }  
+
+  def getVarsList(cond: Cond): List[String] = cond match {
+    case BVal(_)    => List()
+    case And(c1,c2) => getVarsList(c1) ++ getVarsList(c2)
+    case Or(c1,c2)  => getVarsList(c1) ++ getVarsList(c2)
+    case Not(c)     => getVarsList(c)
+    case EQ(l1,l2)    => getVarsList(l1) ++ getVarsList(l2)
+    case GT(l1,l2)    => getVarsList(l1) ++ getVarsList(l2)
+    case LT(l1,l2)    => getVarsList(l1) ++ getVarsList(l2)
+    case GE(l1,l2)    => getVarsList(l1) ++ getVarsList(l2)
+    case LE(l1,l2)    => getVarsList(l1) ++ getVarsList(l2)
+    
+  }
+
+
+/////////////////////////////////////////////////////////////////////////////////
+
+
+
+
+
+
 
-  def toValuation(as:List[Assign],prev:Valuation): Valuation =
-    as.map(kv => kv.v.v -> Eval.lin2sage(kv.e))
+
+
+
+
+
+
+
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+
+/** Convert a list of assignments to a Valuation, i.e., to a Map[String,SyExpr]. */
+  def toValuation(as:List[Assign],prev:Valuation): Valuation = {
+    as.map(kv => kv.v.v -> Eval.notlin2sage(kv.e))
       .toMap
       .view.mapValues(e => exprVarToExpr(e,prev)).toMap
+  }
+
+///////////////////////////////////////////////////////////////////////////////
+
+
+
+
 
+
+
+//////////////////////////////////////////////////////////////////////////////////////
+
+  /** Convert a SyExprVar variable to a SyExpr variable. */
   def exprVarToExpr(e:SyExprVar,prev:Valuation): SyExpr = e match {
-    case SVal(v) => SVal(v)
-    case SVar(v) => prev(v) //throw new RuntimeException(s"Cannot convert a var ($v) to a SyExpr.")
+    case SVal(v) => SVal(v) // because SVal is already an extension of SyExprVar
+    case SVar(v) => prev(v) // v is a string, used as a key to the PREVious values (SyExpr) stored in prev.
+    case SFun("log10",args:List[SyExprVar]) =>SDiv(exprVarToExpr(SFun("log",args),prev),exprVarToExpr(SFun("log",List(SVal(10))),prev))
     case SFun(f, args:List[SyExprVar]) => SFun(f,args.map(exprVarToExpr(_,prev)))
     case SDiv(e1, e2) => SDiv( exprVarToExpr(e1,prev),exprVarToExpr(e2,prev))
+    case SRes(e1, e2) => SRes( exprVarToExpr(e1,prev),exprVarToExpr(e2,prev))
     case SMult(e1, e2)=> SMult(exprVarToExpr(e1,prev),exprVarToExpr(e2,prev))
     case SPow(e1, e2) => SPow( exprVarToExpr(e1,prev),exprVarToExpr(e2,prev))
     case SAdd(e1, e2) => SAdd( exprVarToExpr(e1,prev),exprVarToExpr(e2,prev))
     case SSub(e1, e2) => SSub( exprVarToExpr(e1,prev),exprVarToExpr(e2,prev))
   }
 
+/////////////////////////////////////////////////////////////////////////////////////
+
+
+
+
   def asSyExpr(e:SyExprAll): SyExpr = e match {
     case e2: SyExpr @ unchecked => e2
     // bottom case never caught, since erasure will make SyExprAll = SyExpr.
@@ -142,25 +841,44 @@ object Utils {
     case _ => throw new RuntimeException(s"Failed to interpret ${Show(e)} as a simple expression with variables.")
   }
 
+
+
+
   //////
   // inferring open domains...
   //////
 
-  def fixVars(e:SyExprAll): SyExprAll = e match {
-    case SVal(_) => e
-    case SVar(_) => e
-    case SArg() => e
-    case SFun(f, List(SVal(0))) => SVar(f)
-    case SFun(f, args) => SFun(f,args.map(fixVars))
-    case SDiv(e1, e2) => SDiv( fixVars(e1),fixVars(e2))
-    case SMult(e1, e2)=> SMult(fixVars(e1),fixVars(e2))
-    case SPow(e1, e2) => SPow( fixVars(e1),fixVars(e2))
-    case SAdd(e1, e2) => SAdd( fixVars(e1),fixVars(e2))
-    case SSub(e1, e2) => SSub( fixVars(e1),fixVars(e2))
-  }
 
 
 
+  /** Fixes conventions produced by SageMath */
+  def fixVars(e:SyExprAll): SyExprAll = {
+    val res = e match {
+      case SVal(_) => e
+      case SVar("e") => SFun("E", Nil)
+      case SVar("pi") => SFun("PI", Nil)
+      case SVar(_) => e
+      case SArg() => e
+      case SFun("_e", List(SVal(0))) => SVar("_e")
+      case SFun("_pi", List(SVal(0))) => SVar("_pi")
+      case SFun(f, List(SVal(0)))
+        if (f != "sin" && f != "cos" && f != "tan" && f != "exp" && f != "arcsin" && f != "arccos" && f != "arctan" && f != "sinh" && f != "cosh" && f != "tanh" && f != "sqrt" && f != "log" && f != "log10")=> SVar(f)
+      case SFun("e", args) => SFun("E", args.map(fixVars))
+      case SFun("pi",args)=> SFun("PI", args.map(fixVars))
+      case SFun("log10",args)=>SDiv(fixVars(SFun("log",args)),fixVars(SFun("log",List(SVal(10)))))
+      case SFun(f, args) => SFun(f, args.map(fixVars))
+      case SDiv(e1, e2) => SDiv(fixVars(e1), fixVars(e2))
+      case SRes(e1, e2) => SRes(fixVars(e1), fixVars(e2))
+      case SMult(e1, e2) => SMult(fixVars(e1), fixVars(e2))
+      case SPow(e1, e2) => SPow(fixVars(e1), fixVars(e2))
+      case SAdd(e1, e2) => SAdd(fixVars(e1), fixVars(e2))
+      case SSub(e1, e2) => SSub(fixVars(e1), fixVars(e2))
+    }
+    //println(s"Fixing ${(e)} into ${(res)}")
+    res
+  }
+
+
 //  type Domains = Set[Domain] // possible domains (disjunction)
   type Domain = Map[String,VarDomain] // one domain to a set of variables
   sealed abstract class VarDomain
@@ -180,8 +898,6 @@ object Utils {
       val compat = isLess(h1.to,h2.from) && isLess(h2.to,h1.from)
       if (compat)
         (getP(to),getP(from)) match {
-//          case (None, _) => Some(Hole(Inf, from))
-//          case (_, None) => Some(Hole(to, Inf))
           case (Some(t1), Some(t2)) if t1>t2 => Some(All)
           case (Some(t1), Some(t2)) if t1==t2 =>
             if (to == Close(t1) || from == Close(t1)) Some(All)
@@ -286,17 +1002,14 @@ object Utils {
     case BVal(true) =>  Some(Map()) //Set(Map())
     case BVal(false) =>  None
     case And(c1, c2) =>
-//      (for (d1<-getDomains(c1); d2<-getDomains(c2)) yield andD(d1,d2))
-//        .filter(_.isDefined)
-//        .map(_.get)
       for (d1<-getDomain(c1); d2<-getDomain(c2); d12 <- andD(d1,d2)) yield d12
     case Or(c1, c2) =>
       for (d1<-getDomain(c1); d2<-getDomain(c2)) yield orD(d1,d2)
     case Not(c) => getDomain(c).flatMap(notD)
-    case GT(Var(v), Value(d)) => Some(Map(v->Hole(Inf,Open(d))))
-    case GE(Var(v), Value(d)) => Some(Map(v->Hole(Inf,Close(d))))
-    case LT(Var(v), Value(d)) => Some(Map(v->Hole(Open(d),Inf)))
-    case LE(Var(v), Value(d)) => Some(Map(v->Hole(Close(d),Inf)))
+    case GT(VarNotLin(v), ValueNotLin(d)) => Some(Map(v->Hole(Inf,Open(d))))
+    case GE(VarNotLin(v), ValueNotLin(d)) => Some(Map(v->Hole(Inf,Close(d))))
+    case LT(VarNotLin(v), ValueNotLin(d)) => Some(Map(v->Hole(Open(d),Inf)))
+    case LE(VarNotLin(v), ValueNotLin(d)) => Some(Map(v->Hole(Close(d),Inf)))
     case _ => None
   }
 
diff --git a/src/main/scala/hprog/frontend/solver/LiveSageSolver.scala b/src/main/scala/hprog/frontend/solver/LiveSageSolver.scala
old mode 100644
new mode 100755
index c1611f1..4bbb179
--- a/src/main/scala/hprog/frontend/solver/LiveSageSolver.scala
+++ b/src/main/scala/hprog/frontend/solver/LiveSageSolver.scala
@@ -2,6 +2,7 @@ package hprog.frontend.solver
 
 import hprog.ast.SymbolicExpr.{SyExpr, SyExprAll}
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.common.{ParserException, TimeoutException}
 import hprog.frontend.CommonTypes.{SySolution, Valuation}
@@ -21,18 +22,17 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
   protected val lockSnd = new Object
   protected var last: Option[String] = None
   debug(()=>s" - Sage process: creating (last=$last)")
-  protected val proc = LiveSageSolver.createSageProcess(path,addUpdate)
+  protected val proc = LiveSageSolver.createSageProcess(path,addUpdate) // cria um processo, para correr em paralelo com o Sage
 
   // wait for process to be created (and first output out)
   var count = 10
   while (last!=Some("sage: started") && count>0) { // if not started yet, then wait
     lockRcv.synchronized{
       debug(()=>s"Initial run: waiting to start (last=$last, count=$count)")
-      lockRcv.wait(1000)
+      lockRcv.wait(1000) // tempo de espera para o sage coemeçar
       count -= 1
     }
     lockSnd.synchronized {
-      //last=None
       lockSnd.notify() // in case it is waiting to send more stuff.
       lockSnd.notify() // in case it is waiting to send more stuff.
     }
@@ -43,27 +43,22 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
     debug(()=>"(lince) unlocking (sage)")
     last = None
     lockSnd.notify()
-    //debug(()=>" - done(r)")
   }
 
   def addUpdate(s:String): Unit = {
-    //    last = Some(s)
     lockRcv.synchronized{
       debug(()=>s"(sage) sage reply: '$s'")
       last = Some(s)
       lockRcv.notify()
-      //debug(()=>" - done(s)")
-      //    lockRcv.synchronized(lockRcv.notifyAll())
     }
     lockSnd.synchronized{
       debug(()=>"(sage) waiting up to 20s for (lince) to ack my reply")
       if (last!=None) // if I'm the first, then wait
         lockSnd.wait(20000)
       debug(()=>"(sage) done")
-      //debug(()=>s" - done(s)")
+
     }
-    //debug(()=>s"(sender) continuing")
-    //    l.notify() // null
+
   }
 
   // still unexpectedly locking...
@@ -75,14 +70,12 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
       if (last==None)
         lockRcv.wait(5000)
       debug(()=>"(lince) done")
-      //debug(()=>" - done(r)")
+
     }
     // allow sender to continue after startup msg
     lockSnd.synchronized{
-      //print("(rcv) unlocking sender")
       last = None
       lockSnd.notify()
-      //debug(()=>" - done(r)")
     }
     r
   }
@@ -96,11 +89,7 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
 
   }
 
-  def askSage(s:String): Option[String] = {
-    last = None // clear last answer
-    proc._1(s) // put string in input queue of Sage process
-    waitForReply()
-  }
+
 
   private def waitForReply(): Option[String] = {
     var prev = ""
@@ -108,15 +97,13 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
     while (!ok) {
     // wait for the notification (new value returned)
       lockRcv.synchronized{
-        debug(()=>"(lince) waiting up to 10s for reply")
+        debug(()=>"(lince) waiting up to 40s for reply")
         if (last == None) // I'm the first - wait
           lockRcv.wait(10000)
         debug(()=>"(lince) done")
-        //debug(()=>s"> '${last}'")
       }
       last match {
         case Some("'ok'") =>
-          //debug(()=>s"moving prev '$prev' to last")
           last = Some(prev)
           ok = true
           lockSnd.synchronized{
@@ -125,7 +112,6 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
             lockSnd.notify()
           }
         case Some(v) =>
-          //debug(()=>s"adding $v to prev")
           prev = v.drop(6)
           lockSnd.synchronized{
             debug(()=>"(lince) notifying (sender)")
@@ -136,19 +122,34 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
           return None
       }
     }
-    //debug(()=>s"returning '${prev}' if '$ok'")
     if (ok) Some(prev) else None
   }
 
 
-  ///
+  def askSage(s:String): Option[String] = {
+    last = None // clear last answer
+    proc._1(s) // put string in input queue of Sage process
+    waitForReply()
+  }
+
+  /// 
   def askSage(eqs: List[DiffEq]): Option[String] = {
-    val instructions = genSage(eqs) // + "; print(\"§\")"
-//    debug(()=>s"instructions to solve: '$instructions'")
-    debug(()=>s"solving: ${Show(eqs)}")
+    val instructions = genSage(eqs) // cria uma string das equações diferenciais para enviar para o Sage (ex: _t_=var('_t_'), function('...'))
+    println("eqs_withoutShow:",eqs)
+    println("eqs:",Show(eqs))
+    println("genSage:",instructions)
+    //debug(()=>s"solving: ${Show(eqs)}")
     val rep = askSage(instructions)
-    debug(()=>s"reply: '$rep'")
-    rep
+   // println("olaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
+    println("askSage:",rep)
+   // println("rep.get.contains(g1634):",rep.get.contains("g1634"))
+    if (rep.get.contains("g1634")) {
+     // println("FIND ERROR")
+     return throw new TimeoutException(s"Sage could not find the solution(s) to the differential equation(s): ${Show(eqs)}")
+    } else {
+    return rep
+    }
+   
   }
 
   /**
@@ -158,8 +159,8 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
     */
   private def genSage(eqs:List[DiffEq]): String = {
     var res = "_t_ = var('_t_'); "
-    val undefinedVars = Utils.getUsedVars(eqs) -- Utils.getDefVars(eqs)
-    val eqs2 = eqs ::: undefinedVars.map(v => DiffEq(Var(v),Value(0))).toList
+    val undefinedVars = (Utils.getUsedVarsTHEN(eqs)++Utils.getUsedVarsELSE(eqs)) -- Utils.getDefVars(eqs) //constant vars= Used vars - continuous vars
+    val eqs2 = eqs ::: undefinedVars.map(v => DiffEq(VarNotLin(v),ValueNotLin(0))).toList //NEW  Obliging not to vary in time
 
     for (e <- eqs2)
       res += s"${e.v.v} = function('${e.v.v}')(_t_); "
@@ -168,6 +169,7 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
     res += s"print(expand(desolve_system([${(for(i<-eqs2.indices)yield s"_de${i}_").mkString(",")}]," +
       s"[${eqs2.map(_.v.v).mkString(",")}])))"
     res += ";\"ok\""
+    //println("res:"+res)
     res
   }
 
@@ -178,18 +180,14 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
       vars.map(v=>s"$v = var('$v'); ").mkString +
       "print(" + Show(expr) + "); \"ok\""
     debug(()=>s"expression to solve: '$instructions'")
-//    println(s"expression to solve: '$instructions'")
     val rep = askSage(instructions)
     debug(()=>s"reply: '$rep'")
     rep
   }
 
   def askSage(c:Cond,vl:Valuation): Option[String] = {
-    //val vars = getVars(c)
     val instructions =
       "bool(" + Show(c,vl) + "); \"ok\""
-//      "x = var('x'); "+
-//        "solve([" + Show(c,vl) + " , x==1],x) != []; \"ok\""
     debug(()=>s"expression to solve: '$instructions'")
     val rep = askSage(instructions)
     debug(()=>s"reply: '$rep'")
@@ -203,31 +201,12 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
     case s:SVar        => List(s.v)
     case SFun(_, args) => args.flatMap(getVars) //if (args == List(SVal(0)))
     case SDiv(e1, e2)  => getVars(e1) ++ getVars(e2)
+    case SRes(e1, e2)  => getVars(e1) ++ getVars(e2)
     case SMult(e1, e2) => getVars(e1) ++ getVars(e2)
     case SPow(e1, e2)  => getVars(e1) ++ getVars(e2)
     case SAdd(e1, e2)  => getVars(e1) ++ getVars(e2)
     case SSub(e1, e2)  => getVars(e1) ++ getVars(e2)
   }
-//  private def getVars(c: Cond): List[String] = c match {
-//    case BVal(b) => Nil
-//    case And(c1, c2) => getVars(c1) ++ getVars(c2)
-//    case Or(c1, c2)  => getVars(c1) ++ getVars(c2)
-//    case Not(c2)     => getVars(c2)
-//    case EQ(l1, l2) => getVars(l1) ++ getVars(l2)
-//    case GT(l1, l2) => getVars(l1) ++ getVars(l2)
-//    case LT(l1, l2) => getVars(l1) ++ getVars(l2)
-//    case GE(l1, l2) => getVars(l1) ++ getVars(l2)
-//    case LE(l1, l2) => getVars(l1) ++ getVars(l2)
-//  }
-//
-//  private def getVars(lin: Lin): List[String] = lin match {
-//    case Var(v)      => List(v)
-//    case Value(v)    => Nil
-//    case Add(l1, l2) => getVars(l1) ++ getVars(l2)
-//    case Mult(v, l)  => getVars(l)
-//  }
-
-
 
 
   /**
@@ -242,7 +221,7 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
           throw new TimeoutException(s"Timed out while solving ${
             eqs.map(Show(_)).mkString(", ")}.")
 
-      }//SageSolver.callSageSolver(eqs, path)
+      }
     }
 
   override def +=(expr: SyExprAll): Unit =
@@ -250,7 +229,7 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
       askSage(expr) match {
         case Some(reply) => importExpr(expr,reply)
         case None =>
-          throw new TimeoutException(s"Timed out while reducing ${
+          throw new TimeoutException(s"There are expressions, coming from the differential equations calculated by Sage, which are too large to be simplified by it, causing timeout error.\n\nExpression in question: ${
             Show(expr)}.")
       }
     }
@@ -260,9 +239,8 @@ class LiveSageSolver(path:String) extends StaticSageSolver {
       askSage(cond,valua) match {
         case Some(reply) => importBool(cond, valua, reply)
         case None =>
-          throw new TimeoutException(s"Timed out while solving condition ${
-            Show(cond,valua)
-          }.")
+          throw new TimeoutException(s"Conditional structure with expressions too large to be simplified by Sage, causing timeout error.\n\nThe conditional structure referred to is: ${
+        Show(cond,valua)}.")
       }
     }
   }
@@ -285,6 +263,7 @@ object LiveSageSolver {
     // limit scope of any temporary variables
     // locally {
     val sage = s"$path/sage"
+    //val sage = "\"C:\\Users\\Ricardo Correia\\AppData\\Local\\SageMath 9.3\\runtime\\bin\\mintty.exe\" -t 'SageMath 9.3 Console' -i sagemath.ico /bin/bash --login -c '/opt/sagemath-9.3/sage'"
     // strings are implicitly converted to ProcessBuilder
     // via scala.sys.process.ProcessImplicits.stringToProcess(_)
     val io = new ProcessIO(
@@ -302,24 +281,15 @@ object LiveSageSolver {
         val src = scala.io.Source.fromInputStream(out)
         //debug(()=>"out stream created")
         for (line <- src.getLines()) {
-          //debug(()=>"calling callback")
           callback(line)
-          //debug(()=>"Answer: " + line)
         }
         src.close()
       },
       // We don't want to use stderr, so just close it.
       _.close()
-//      err => {
-//        val src = scala.io.Source.fromInputStream(err)
-//        debug(()=>"err stream created")
-//        for (line <- src.getLines()) {
-//          debug(()=>"error: "+line)
-//        }
-//        src.close()
-//      }
+
     )
-    //println("/ calling Sage")
+
     val calcProc = sage.run(io)
 
     // Using ProcessBuilder.run() will automatically launch
@@ -331,14 +301,11 @@ object LiveSageSolver {
       writer.flush()
     }
     def finished(): Int = {
-      //println("\\_closing Sage")
       writer.close()
       val code = calcProc.exitValue()
-      //debug(()=>s"Subprocess exited with code $code.")
       code
     }
     def finished2(): Unit = {
-      //println("\\_closing Sage")
       writer.close()
     }
 
@@ -355,62 +322,6 @@ object LiveSageSolver {
   class SolvingException(s:String) extends RuntimeException(s)
 
 
-  // DEPRECATED - when calling all in one go. Now calling one eqs at a time
-  //  def callSageSolver(systems: List[List[DiffEq]], path: String, timeout:Int = 10): List[String] = {
-  //    if (systems.filter(_.nonEmpty).nonEmpty) {
-  //      //println(s"solving Sage with ${systems}")
-  //      val instructions = systems.map(LiveSageSolver.genSage).mkString("; print(\"§\"); ")
-  //
-  //      println(s"instructions to solve: ${instructions}")
-  //
-  //      val stdout = new StringBuilder
-  //      val stderr = new StringBuilder
-  //      val status = s"timeout $timeout $path/sage -c $instructions" !
-  //                   ProcessLogger(stdout append _, stderr append _)
-  //      if (status == 0)
-  //        stdout.split('§').toList
-  //      else
-  //        throw new LiveSageSolver.SolvingException(stderr.toString)
-  //    }
-  //    else
-  //      Nil
-  //  }
-
-  //// running sage the 2nd time
-  //  private def genSage(c:Cond): String = c match {
-  //    case BVal(b) => b.toString
-  //    case And(c1, c2) => s"(${genSage(c1)} & ${genSage(c2)})"
-  //    case Or(c1, c2) => s"(${genSage(c1)} | ${genSage(c2)})"
-  //    case Not(c) =>s"not(${genSage(c)})"
-  //    case EQ(l1, l2) => s"(__${genSage(l1)} == ${genSage(l2)})"
-  //    case GT(l1, l2) => s"(__${genSage(l1)} >  ${genSage(l2)})"
-  //    case LT(l1, l2) => s"(__${genSage(l1)} <  ${genSage(l2)})"
-  //    case GE(l1, l2) => s"(__${genSage(l1)} >= ${genSage(l2)})"
-  //    case LE(l1, l2) => s"(__${genSage(l1)} <= ${genSage(l2)})"
-  //  }
-  //  private def genSage(lin: Lin): String = lin match {
-  //    case Var(v) => v
-  //    case Value(v) => v.toString
-  //    case Add(l1, l2) => s"(${genSage(l1)} + ${genSage(l2)}"
-  //    case Mult(v, l) => s"(${v.v} * ${genSage(l)}"
-  //  }
-  //  private def genSage(e: SyExprAll): String = e match {
-  //    case SVal(v) => v.toString
-  //    case _:SArg => "_t_"
-  //    case s:SVar => "__"+s.v
-  //    case SFun(f,args) => s"$f(${args.map(genSage).mkString(",")})"
-  //    case SDiv(e1, e2) => s"(${genSage(e1)} / ${genSage(e2)})"
-  //    case SMult(e1, e2) =>s"(${genSage(e1)} * ${genSage(e2)})"
-  //    case SPow(e1, e2) => s"(${genSage(e1)} ^ ${genSage(e2)})"
-  //    case SAdd(e1, e2) => s"(${genSage(e1)} + ${genSage(e2)})"
-  //    case SSub(e1, e2) => s"(${genSage(e1)} - ${genSage(e2)})"
-  //  }
-  //  private def genSage(sol:SySolution): String =
-  //    sol.map(kv => s"__${kv._1} = ${genSage(kv._2)};").mkString
-  //  def genSage(c:Cond,s:SySolution): String =
-  //    s"${genSage(s)} print(${genSage(c)})"
-
-
 }
 
 
diff --git a/src/main/scala/hprog/frontend/solver/SimpleSolver.scala b/src/main/scala/hprog/frontend/solver/SimpleSolver.scala
old mode 100644
new mode 100755
index 961ab07..034637f
--- a/src/main/scala/hprog/frontend/solver/SimpleSolver.scala
+++ b/src/main/scala/hprog/frontend/solver/SimpleSolver.scala
@@ -1,8 +1,9 @@
 package hprog.frontend.solver
 
 import hprog.ast.SymbolicExpr.SyExprAll
-import hprog.ast.{Cond, DiffEq}
+import hprog.ast._
 import hprog.frontend.Eval
+import Syntax._
 import hprog.frontend.CommonTypes.{Point, Solution, SySolution, Valuation}
 
 // Numerical solver, using a naive solution for differencital equations
@@ -11,11 +12,9 @@ import hprog.frontend.CommonTypes.{Point, Solution, SySolution, Valuation}
 class SimpleSolver extends Solver {
 
   type DValuation = Map[String,Double]
-//  override def ++=(systems: List[List[DiffEq]]): Unit = {}
-//  override def ++=(syntax: Syntax): Unit = {}
-//  override def +=(eqs: List[DiffEq]): Unit = {}
   override def evalFun(eqs: List[DiffEq]): Solution = {
-    val vars = Solver.getVars(eqs).filterNot(_.startsWith("_"))
+    val vars = Solver.getVars(eqs).filter(_.startsWith("_")) // NEW
+    println("vars_SimpleSolver:",vars)
     vars.map(v=> v -> ( (t:Double) => (init:Point ) =>
       callTaylorSolver(init,eqs)(t)(v)
       )).toMap
@@ -25,35 +24,35 @@ class SimpleSolver extends Solver {
   override def solveSymb(expr: SyExprAll): SyExprAll = expr
   override def solveSymb(cond: Cond, v:Valuation): Boolean = Eval(Eval(v),cond)
 
-//  override def solveSymb(eqs: List[DiffEq]): SageSolution = Map()
+
 
 
   private def callTaylorSolver(input:DValuation , eqs:List[DiffEq]): Double => DValuation  = {
+    println("input:",input)
+    println("eqs:",eqs)
+
     val (vars,mtx): (List[String],List[List[Double]]) = Solver.getMatrix(eqs)
+    println("(vars,mtx):",(vars,mtx))
+
     val sol1: (List[Double],Double) => List[Double] = Solver.solveTaylorManual(mtx)
+    //println("sol1:",sol1)
 
-    //    println(s"## calling solver" +
-    //      s"\neqs:\n  ${eqs.mkString("\n  ")}" +
-    //      s"\ninput: ${input.map(p=>s"${p._1}->${p._2}").mkString(", ")}" +
-    //      s"\nvars: ${vars.mkString(",")}" +
-    //      s"\nmtx:\n  ${mtx.map(_.mkString("\t")).mkString("\n  ")}")
-    //println("## Sage\n"+genSage(eqs))
-    //println(s"calling solver for ${input} and ${eqs.map(Show(_)).mkString(",")}")
     def sol(t:Double): DValuation  = {
       // "input" should have all variables but no "" - this should be assigned to 0
       def getDummy(v:String): Double = (vars.indexOf(v),vars.indexOf("_"+v)) match {
         case (_,-1) => 0.0
         case (_,_)  =>
-          //println(s"dummy($v) = ${mtx(i)(j)}")
-          //mtx(i)(j)
           1
       }
       val dummies = vars.map(v => ("_"+v) -> getDummy(v))
+      println("dummies:",dummies)
+
       val input2  = vars.map(input ++ dummies)
-      //      println("input with dummies: "+input2.mkString(","))
+      println("input2:",input2)
+
       val list = sol1(input2, t)
-//      println(s"solving: got list ${list.size}")
-//      println(s"solving: returning ${(vars zip list).toMap -- vars.map("_"+_)}")
+      println("list:",list)
+
       (vars zip list).toMap -- vars.map("_"+_)
     }
     sol
diff --git a/src/main/scala/hprog/frontend/solver/Solver.scala b/src/main/scala/hprog/frontend/solver/Solver.scala
old mode 100644
new mode 100755
index 8ac535b..98d19d9
--- a/src/main/scala/hprog/frontend/solver/Solver.scala
+++ b/src/main/scala/hprog/frontend/solver/Solver.scala
@@ -4,12 +4,15 @@ import breeze.linalg._
 import breeze.numerics._
 import hprog.ast.SymbolicExpr.{Pure, SyExpr, SyExprAll}
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.frontend.CommonTypes._
 import hprog.frontend.Eval
 import hprog.frontend.Utils.asSyExpr
 
 import scala.collection.immutable
+import scala.math._
+
 
 trait Solver {
 
@@ -54,32 +57,88 @@ object Solver {
   private def getVars(eq:DiffEq): List[String] =
     eq.v.v :: getVars(eq.e,eq.v.v)
 
-  private def getVars(e:Lin,base:String): List[String] = e match {
-    case Var(v) => List(v)
-    case Value(v) => List("_"+base)
-    case Add(l1, l2) => getVars(l1,base) ::: getVars(l2,base)
-    case Mult(v, l) => getVars(l,base)
+//New
+  private def getVars(e:NotLin,base:String): List[String] = e match {
+    case VarNotLin(v) => List(v)
+    case ValueNotLin(v) => List()
+    case AddNotLin(l1, l2) => getVars(l1,base) ::: getVars(l2,base)
+    case MultNotLin(l1, l2) => getVars(l1,base) ::: getVars(l2,base)
+    case DivNotLin(l1,l2) => getVars(l1,base) ::: getVars(l2,base)
+    case ResNotLin(l1,l2) => getVars(l1,base) ::: getVars(l2,base)
+    case PowNotLin(l1,l2) => getVars(l1,base) ::: getVars(l2,base)
+    case FuncNotLin(s,list) => getVarsAux(list,base)
+  }
+
+//new
+  def getVarsAux(list:List[NotLin],base:String): List[String] = list match {
+    case List() => List()
+    case n::List() => getVars(n,base)
+    case n::ns => getVars(n,base) ::: getVarsAux(ns,base)
+  }  
+  def getVars_Numerical(eqs:List[DiffEq]): List[String] =
+    eqs.flatMap(getVars_Numerical).distinct
+
+  private def getVars_Numerical(eq:DiffEq): List[String] =
+    eq.v.v :: getVars_Numerical(eq.e,eq.v.v)
+
+  private def getVars_Numerical(e:NotLin,base:String): List[String] = e match {
+    case VarNotLin(v) => List(v)
+    case ValueNotLin(v) => List("_"+base)
+    case AddNotLin(l1, l2) => getVars_Numerical(l1,base) ::: getVars_Numerical(l2,base)
+    case MultNotLin(l1, l2) => getVars_Numerical(l1,base) ::: getVars_Numerical(l2,base)
+    case DivNotLin(l1,l2) => getVars_Numerical(l1,base) ::: getVars_Numerical(l2,base)
+    case ResNotLin(l1,l2) => getVars_Numerical(l1,base) ::: getVars_Numerical(l2,base)
+    case PowNotLin(l1,l2) => getVars_Numerical(l1,base) ::: getVars_Numerical(l2,base)
+    case FuncNotLin(s,list) => getVarsAux_Numerical(list,base)
   }
+//new
+  def getVarsAux_Numerical(list:List[NotLin],base:String): List[String] = list match {
+    case List() => List()
+    case n::List() => getVars_Numerical(n,base)
+    case n::ns => getVars_Numerical(n,base) ::: getVarsAux_Numerical(ns,base)
+  }  
 
   def getMatrix(eqs:List[DiffEq]): (List[String],List[List[Double]]) = {
-    val vars = getVars(eqs)
-    //println(s"## collected vars: ${vars.map("'"+_+"'").mkString(", ")}")
+    val vars = getVars_Numerical(eqs)
+    println("vars_getmatrix:",vars)
     val rows = eqs.map((x:DiffEq) => x.v.v -> getRow(vars,x.v.v,x.e)).toMap
+    println("row_getmatrix:",rows)
     (  vars
       ,for (v<-vars) yield rows.getOrElse(v,vars.map(_ => 0.0))) // Note: set to 0 when unknown variable
   }
 
-  private def getRow(vars:List[String],base:String,e:Lin): List[Double] = {
+
+  private def getRow(vars:List[String],base:String,e:NotLin): List[Double] = {
     val m = getRowValues(e,base)
-    vars.map(x => m.getOrElse[Double](x,0))
+    println("m_getrow:",m)
+    println("vars.map(x => m.getOrElse[Double](x,0)):",vars.map(x => m.getOrElse[Double](x,0)))
+    return vars.map(x => m.getOrElse[Double](x,0))
   }
 
-  private def getRowValues(e:Lin,base:String): Map[String,Double] = e match {
-    case Var(v) => Map(v->1)
-    case Value(v) => Map(("_"+base)->v)
-    case Add(l1, l2) => join(getRowValues(l1,base),getRowValues(l2,base))
-    case Mult(v, l) => getRowValues(l,base).view.mapValues(_*v.v).toMap
-  }
+
+
+
+
+
+
+  private def getRowValues(e:NotLin,base:String): Map[String,Double] = {
+    var res:Map[String,Double]=e match {
+            case VarNotLin(v) => Map(v->1)
+            case ValueNotLin(v) => Map(("_"+base)->v) //New 
+            case AddNotLin(l1, l2) => join(getRowValues(l1,base),getRowValues(l2,base))
+            case MultNotLin(l1, l2) => multjoin(getRowValues(l1,base),getRowValues(l2,base)) //new
+            case DivNotLin(l1,l2) => divjoin(getRowValues(l1,base),getRowValues(l2,base)) //new
+            case ResNotLin(l1,l2) => resjoin(getRowValues(l1,base),getRowValues(l2,base)) //new
+            case PowNotLin(l1,l2) => powjoin(getRowValues(l1,base),getRowValues(l2,base)) //new
+            case FuncNotLin(s,list) => funcjoin(s,list.map((l:NotLin) => getRowValues(l,base)),base) //new
+             
+          }
+      println(s"getRowValues: notlin->${e} to ${res}")
+      res
+    }
+
+
+
   //  private def multt(d:Double,d2:Double): Double = d*d2
   private def join(m1:Map[String,Double],m2:Map[String,Double]): Map[String,Double] = {
     var res = m2
@@ -90,10 +149,117 @@ object Solver {
     res
   }
 
+//New
+    private def multjoin(m1:Map[String,Double],m2:Map[String,Double]): Map[String,Double] = {
+    var res = m2
+    for ((k, v1) <- m1) m2.get(k) match {
+      case Some(v2) => val v = v1*v2; res += k -> v
+      case None => res += k->v1
+    }
+    res
+  }
+
+
+//New
+  private def divjoin(m1:Map[String,Double],m2:Map[String,Double]): Map[String,Double] = {
+    var res = m2
+    for ((k, v1) <- m1) m2.get(k) match {
+      case Some(v2) => val v = v1/v2; res += k -> v
+      case None => res += k->v1
+    }
+    res
+  }
+
+  //New
+  private def resjoin(m1:Map[String,Double],m2:Map[String,Double]): Map[String,Double] = {
+    var res = m2
+    for ((k, v1) <- m1) m2.get(k) match {
+      case Some(v2) => val v = v1%v2; res += k -> v
+      case None => res += k->v1
+    }
+    res
+  }
+
+
+//New
+  private def powjoin(m1:Map[String,Double],m2:Map[String,Double]): Map[String,Double] = {
+    var res = m2
+    for ((k, v1) <- m1) m2.get(k) match {
+      case Some(v2) => val v = math.pow(v1,v2); res += k -> v
+      case None => res += k->v1
+    }
+    res
+  }
+
+
+//New
+  private def funcjoin(s:String,list:List[Map[String,Double]],base:String):Map[String,Double] ={
+      if(list.length == 0 || list.length>2){
+        s match {
+          case ("PI") => Map(("_"+base) -> math.Pi) //new
+          case ("E") => Map(("_"+base) -> math.E) // new
+          case (_) => throw new RuntimeException(s"Unknown function '${s}',or the number of arguments are incorrect")
+        }
+        
+      }
+      else {
+        if (list.length == 1){
+          s match {
+            case ("exp") => list(0).map(v => v._1 -> math.exp(v._2))
+            case ("sin") => list(0).map(v => v._1 -> math.sin(v._2))
+            case ("cos") => list(0).map(v => v._1 -> math.cos(v._2))
+            case ("tan") => list(0).map(v => v._1 -> math.tan(v._2))
+            case ("arcsin") => list(0).map(v => v._1 -> math.asin(v._2))
+            case ("arccos") => list(0).map(v => v._1 -> math.acos(v._2))
+            case ("arctan") => list(0).map(v => v._1 -> math.atan(v._2))
+            case ("sinh") => list(0).map(v => v._1 -> math.sinh(v._2))
+            case ("cosh") => list(0).map(v => v._1 -> math.cosh(v._2))
+            case ("tanh") => list(0).map(v => v._1 -> math.tanh(v._2))
+            case ("sqrt") => list(0).map(v => v._1 -> math.sqrt(v._2))
+            case ("log") => list(0).map(v => v._1 -> math.log(v._2))
+            case ("log10") => list(0).map(v => v._1 -> math.log10(v._2))
+            case (_)=>throw new RuntimeException(s"Unknown function '${s}',or the number of arguments are incorrect")
+          }
+        }
+        else {
+          s match {
+            case ("max") => list(0) ++ (for ((x,v) <- list(1)) yield x -> (if (list(0).contains(x))  math.max((list(0))(x),v) else v))
+            case ("min") => list(0) ++ (for ((x,v) <- list(1)) yield x -> (if (list(0).contains(x))  math.min((list(0))(x),v) else v))
+            case (_)=>throw new RuntimeException(s"Unknown function '${s}',or the number of arguments are incorrect")
+          }  
+        }
+
+      }
+    }
+
+
+
+  @deprecated
+  private def mult(m1:Map[String,Double],m2:Map[String,Double]): Map[String,Double] = {
+    var res = m2
+    for ((k, v1) <- m1) m2.get(k) match {
+      case Some(v2) => val v = v1*v2; res += k -> v
+      case None => res += k->v1
+    }
+    res
+  }
+
+////////////////////////////////////////////////////////////////
+
+
+
+
+
+
+
+
+
+
+
+
   private def list2Matrix(m:List[List[Double]]): DenseMatrix[Double] = {
     val rows = m.size
     val cols = m.headOption.getOrElse(Nil).size
-//    println("before toMtr: "+m)
     DenseMatrix.create(cols,rows,m.flatten.toArray).t
   }
 
@@ -101,25 +267,17 @@ object Solver {
 
   def estimateDur(until:Until, eqs:List[DiffEq], x:Valuation, solver:Solver): Option[(Double,Option[Double=>String])] = {
     val sol = solver.evalFun(eqs) // maps variables to their solutions (function from t/ctx to value)
-//    println(s"Estimating duration using point ${Show(x)}.")
     def guard: Double => Boolean =
       t => {
-//        println(s" - guard ${c} @ $t")
-//        solver.solveSymb(until.c,x)
         Eval(sol.view.mapValues(fun=>fun(t)(Eval(x))).toMap,until.c)
       }
-//    println(" - going")
     val durValue = searchCond(until,guard,solver) // give value or do jumps searching for duration
-    //debug(()=>s"Solving duration for ${Show(eqs)} & ${Show(diffEqs.dur)} - ${durValue}")
-    //debug(()=>s"knowing ${Show(input)}")
-//    println(s" - done $durValue")
     durValue
   }
 
   def searchCond[X](until:Until, guard:Double=>Boolean,solver:Solver): Option[(Double,Option[Double=>String])] = {
     if (guard(0.0)) Some((0.0,None))
        else
-        //logSearch(1, 0, None)(guard, precision = until.eps)
         stepwiseSearch(0,until.jump,until.eps,guard,until.c,solver)
   }
 
@@ -143,10 +301,10 @@ object Solver {
     println("## eigV: "+ev.toArray.mkString(", "))
 
     def sol(x0:List[Double],t:Double): List[Double] = {
-            println("##### E:\n"+diag(exp(ev *:* t)))
-            println("##### pEp-1:\n"+p * diag(exp(ev *:* t)) * pi)
+            println("##### E:\n"+diag(breeze.numerics.exp(ev *:* t)))
+            println("##### pEp-1:\n"+p * diag(breeze.numerics.exp(ev *:* t)) * pi)
             println(s"##### x0=${x0.mkString(",")} ")
-      val res = p * diag(exp(ev *:* t)) * pi * list2Matrix(x0.map(List(_)))
+      val res = p * diag(breeze.numerics.exp(ev *:* t)) * pi * list2Matrix(x0.map(List(_)))
             println(s"--- sol($t) = ${res.t}")
       res.data.toList
     }
@@ -166,7 +324,7 @@ object Solver {
     val id = DenseMatrix.eye[Double](size)
 
     def fact(n:Int):Int = if (n<=0) 1 else n * fact(n-1)
-    def avg(m:DenseMatrix[Double]): Double = m.data.map(abs(_)).sum / m.size
+    def avg(m:DenseMatrix[Double]): Double = m.data.map(breeze.numerics.abs(_)).sum / m.size
 
     def sol(x0:List[Double],t:Double): List[Double] = {
       val at = a * t
@@ -177,7 +335,6 @@ object Solver {
         val res = cur + next
         // TODO: control precision and use error
         val av = avg(next)
-//        println(s"avg: $av")
         if (av.isNaN || avg(next) < precision)
           res
         else
@@ -199,8 +356,7 @@ object Solver {
     * @param precision
     * @return
     */
-  def solveTaylorManual(a:List[List[Double]],precision:Double = 0.0000001, maxSteps:Int=100):  (List[Double],Double) => List[Double] = {
-    //println("building ODE "+a.mkString("/"))
+  def solveTaylorManual(a:List[List[Double]],precision:Double = 0.0000001, maxSteps:Int=100): (List[Double],Double) => List[Double] = {
     val size = a.size // square matrix
 
     type Row=List[Double]
@@ -216,6 +372,7 @@ object Solver {
     }
 
     val id = myEye(size,0)
+    println("id_STM:",id)
 
     def mPlusm(m1: Matrix, m2: Matrix): Matrix = {
       (m1 zip m2).map(x => x._1.zip(x._2).map(y=>y._1+y._2))
@@ -233,7 +390,6 @@ object Solver {
           dotProd( m1row, m2col )
 
     def sol(x0:List[Double],t:Double): List[Double] = {
-      //print(s"t=$t -")
       val at = a.map(_.map(_*t))
 
       @scala.annotation.tailrec
@@ -244,10 +400,6 @@ object Solver {
         val res = mPlusm(cur,next)
         // TODO: control precision and use error
         val av = avg(next)
-        //        println(s"avg: $av")
-//        if (res.nonEmpty && res.head.nonEmpty && res.head.head.isNaN)
-//          cur
-        //else
         if (av.isNaN || avg(next) < precision || step>maxSteps)
           res
         else
@@ -255,7 +407,6 @@ object Solver {
       }
 
       val res = mXm(iter(1,id,id) , x0.map(List(_)) )
-      //println("res="+res.flatten.mkString(","))
       res.flatten
     }
 
@@ -264,73 +415,9 @@ object Solver {
 
 
 
-  ////////////////////////
-  /// TESTING FUNCTIONS //
-  ////////////////////////
-
-//  def getDiffEqs(prog:Syntax): List[List[DiffEq]]  = prog match {
-//    case d@DiffEqs(eqs, dur) => List(eqs)
-//    //    case Seq(Nil) => Nil
-//    case Seq(p::ps) =>
-//      getDiffEqs(p) ::: getDiffEqs(Seq(ps))
-//    //    case Skip => Nil
-//    case ITE(ifP, thenP, elseP) =>
-//      getDiffEqs(thenP) ++ getDiffEqs(elseP)
-//    case While(c, doP) => getDiffEqs(doP)
-//    case _ => Nil
-//  }
-
-
-//
-//
-//  def getFstDiffEq(prog:Syntax): DiffEqs  = prog match {
-////    case Assign(v, e) => Nil
-//    case d@DiffEqs(eqs, dur) => d
-////    case Seq(Nil) => Nil
-//    case Seq(p::ps) =>
-//      try getFstDiffEq(p)
-//      catch {
-//        case _: Throwable => getFstDiffEq(Seq(ps))
-//      }
-////    case Skip => Nil
-//    case ITE(ifP, thenP, elseP) =>
-//      try getFstDiffEq(thenP)
-//      catch {
-//        case _: Throwable => getFstDiffEq(elseP)
-//      }
-//    case While(c, doP) => getFstDiffEq(doP)
-//    case _ => throw new RuntimeException("no diff. eq. found")
-//  }
-//
-//  def getFstMatrix(prog:Syntax): List[List[Double]] =
-//    getMatrix(getFstDiffEq(prog).eqs)._2
-//
-//  def tryM(prog:String): List[List[Double]] = getFstMatrix(DSL.parse(prog))
-//
-//
-//
-//  /**
-//    * Performs a gradient descent, i.e., searches for an argument "t" of "function" s.t. function(t) = 0.
-//    * From wikipedia - not in use.
-//    * @param previousStepSize how closer it got since the last try
-//    * @param curX initial value
-//    * @param function to find a 0
-//    * @param precision goal (the new step being smaller than the precision)
-//    * @param gamma difference used to calculate derivative
-//    * @return the argument of the function that yields 0
-//    */
-//  def gradientDescent(previousStepSize: Double= 1/0.000001, curX: Double = 0,
-//                      function: Double => Double,
-//                      precision: Double = 0.000001, gamma: Double = 0.01): Double = {
-//    if (previousStepSize > precision) {
-//      val newX = curX + -gamma * function(curX)
-//      println(curX)
-//      // update previousStepSize and curX
-//      gradientDescent(abs(newX - curX), newX, function, precision, gamma)
-//    } else curX
-//  }
-////  val ans = gradientDescent(previousStepSize, curX, precision, gamma)
-////  println(s"The local minimum occurs at $ans")
+ 
+
+
 
   /**
     * Searches for the earliest value at which a given guard becomes true.
@@ -348,7 +435,6 @@ object Solver {
   def logSearchRec(jump:Double, curX: Double, last:Option[(Double,Double)])
                   (implicit guard: Double => Boolean,
                    precision: Double = 0.00000001, max: Int = 1000000) : Option[(Double,Double)] = {
-    //println(s"[SS-log] $curX by $jump (last: $last)")
     if (max<curX)  return None
 
     last match {
@@ -368,7 +454,6 @@ object Solver {
             logSearchRec(jump/2,curX + jump,last)
         }
         else {
-          //println(s"[SS-log] got $last (precision: ${jump*2})")
           last
         }
     }
@@ -390,7 +475,6 @@ object Solver {
                      guard:     Double => Boolean,
                      guardCond: Cond,
                      solver:    Solver): Option[(Double,Option[Double=>String])] = {
-    //println(s"[SS-jump] $curX by $jump")
     (bigStep,smallStep) match {
       case (_,None)                  =>
         logSearch(1,curX,curX,None,guard,guardCond,100000000)
@@ -427,7 +511,6 @@ object Solver {
                                        step:SyExpr,
                                        max:Int,
                                        solver:Solver): Option[Double] = {
-    //println(s"[SS-basic] $curX by $step")
     val now = Eval(curX)
     if      (max<now)     None
     else if (guard(now))  Some(now)
@@ -448,120 +531,6 @@ object Solver {
   }
 
 
-  /////////////////////////////////////////////////
-//
-//  /**
-//    * Searches for the earliest value at which a given guard becomes true.
-//    * Initially it grows exponentially until it finds a "true",
-//    * once it does, searches for the initial value up to some precision.
-//    * Assumes that, once the guard it true, it will always be true.
-//    *
-//    * @param jump The distance backwards when the guard was false.
-//    * @param curX Current value being evaluated
-//    * @param guard The function that checks if the value holds
-//    * @param precision The maximum error
-//    * @return The earliest value at which the guard is true, if it exists before "max", and the largest value traversed
-//    */
-//  @scala.annotation.tailrec
-//  def logSearchRec(jump:Double, curX: Double, last:Option[(SyExpr,SyExpr)])
-//                  (implicit guard: SyExpr => Boolean,
-//                   precision: Double = 0.00000001, max: Int = 1000000) : Option[(SyExpr,SyExpr)] = {
-//    //println(s"[SS-log] $curX by $jump (last: $last)")
-//    if (max<curX)  return None
-//
-//    last match {
-//      // no value found yet - growing search
-//      case None =>
-//        if (guard(SVal(curX))) // FOUND! define last, start shrinking
-//        logSearchRec(jump/8,curX - jump/4, Some((SVal(curX),SVal(curX))))
-//        else // need to jump more
-//        logSearchRec(jump*2,curX + jump  ,None)
-//
-//      // growing steps until guard succeeds
-//      case Some((v1,v2)) =>
-//        if (jump*2 > precision) { // shrinking steps until having the right precision
-//          if (guard(SVal(curX)))
-//            logSearchRec(jump/2,curX - jump, Some(SVal(curX),v2))
-//          else
-//            logSearchRec(jump/2,curX + jump,last)
-//        }
-//        else {
-//          //println(s"[SS-log] got $last (precision: ${jump*2})")
-//          last
-//        }
-//    }
-//  }
-//
-//  /**
-//    * Searches for the earliest time `t` a predicate `guard(t)` holds by jumping and trying
-//    * @param curX next time value to try
-//    * @param bigStep   if None: smallStep is the naive step
-//    *                  if Some(step): just forward step until guard(t), then logSearch with precision smallStep
-//    * @param smallStep if None: ignore bigstep, and do log search up and down with fixed precision
-//    *                  if Some(step): use step as jump forward of precision, based on bigStep.
-//    * @param guard predicate parameterised by the time
-//    * @return
-//    */
-//  def stepwiseSearch(curX:      SyExpr,
-//                     bigStep:   Option[Double],
-//                     smallStep: Option[Double],
-//                     guard:     SyExpr => Boolean,
-//                     guardCond: Cond,
-//                     solver:    Solver): Option[(SyExpr,Option[Double=>String])] = {
-//    //println(s"[SS-jump] $curX by $jump")
-//    (bigStep,smallStep) match {
-//      case (_,None)                  =>
-//        logSearch(1,Eval(curX),curX,None,guard,guardCond,100000000)
-//      case (None,Some(step))         =>
-//        stepwiseSearchSmallSteps(curX)(guard,step,(Eval(curX)+1000000*step).toInt,solver).map((_,None))
-//      case (Some(bstep),Some(sstep)) =>
-//        stepwiseSearchBigSteps(curX)((bstep,sstep),guard,guardCond,Eval(curX)+1000000*bstep,solver)
-//    }
-//  }
-//
-//  @scala.annotation.tailrec
-//  private def stepwiseSearchBigSteps(curX: SyExpr)
-//                                    (implicit bigSmallStep:(Double,Double),
-//                                     guard: SyExpr=>Boolean, guardCond:Cond,
-//                                     max:Double,
-//                                     solver:Solver): Option[(SyExpr,Option[Double=>String])] = {
-//    if (max<Eval(curX))
-//      None
-//    else if (guard(curX)) // overshoot - now go slowly
-//    logSearch(
-//      bigSmallStep._1/4,
-//      Eval(curX) - bigSmallStep._1/2,
-//      solver.solveSymbExpr(SSub[Pure](curX,SVal(bigSmallStep._1))),
-//      Some(curX),
-//      guard,guardCond,max.toInt,bigSmallStep._2)
-//    else
-//    stepwiseSearchBigSteps(solver.solveSymbExpr(SAdd[Pure](curX , SVal(bigSmallStep._1))))
-//  }
-//
-//  @scala.annotation.tailrec
-//  private def stepwiseSearchSmallSteps(curX: SyExpr)
-//                                      (implicit guard: SyExpr => Boolean,
-//                                       step:Double,
-//                                       max:Int,
-//                                       solver:Solver): Option[SyExpr] = {
-//    //println(s"[SS-basic] $curX by $step")
-//    if      (max<Eval(curX))     None
-//    else if (guard(curX))  Some(curX)
-//    else                   stepwiseSearchSmallSteps(solver.solveSymbExpr(SAdd[Pure](curX,SVal(step))))
-//  }
-//
-//  def logSearch(jump:Double, curX: Double, first:SyExpr, last:Option[SyExpr], guard: SyExpr=>Boolean,
-//                guardCond: Cond,
-//                max: Int,
-//                precision: Double = 0.00000001) : Option[(SyExpr,Option[Double=>String])] = {
-//    val res = logSearchRec(jump,curX,last.map(x=>(x,x)))(guard,precision,max)
-//    res.map(res => (res._1 , Some( t =>
-//      //        s"found logsearch at ${res._1} starting from ${first} until ${res._2}, curX=$curX"
-//      s"Assuming ${Show(guardCond)} becomes true only once</br>" +
-//        s"Interval: ${t-(Eval(res._1)-Eval(first))} -> ${t+(Eval(res._2)-Eval(res._1))}" +
-//        s"Precision: $precision</br>"
-//      //      s"on $curX-${res._2}"
-//    )))
-//  }
+
 
   }
diff --git a/src/main/scala/hprog/frontend/solver/StaticSageSolver.scala b/src/main/scala/hprog/frontend/solver/StaticSageSolver.scala
old mode 100644
new mode 100755
index 5042e48..6c40084
--- a/src/main/scala/hprog/frontend/solver/StaticSageSolver.scala
+++ b/src/main/scala/hprog/frontend/solver/StaticSageSolver.scala
@@ -2,6 +2,7 @@ package hprog.frontend.solver
 
 import hprog.ast.SymbolicExpr.{SyExpr, SyExprAll, SyExprTime}
 import hprog.ast._
+import Syntax._
 import hprog.backend.Show
 import hprog.common.ParserException
 import hprog.frontend.CommonTypes.{SySolution, Valuation, Warnings}
@@ -66,13 +67,9 @@ class StaticSageSolver extends Solver {
     if (!cacheDE.contains(eqs) && !cacheStrDE.contains(Show(eqs)))
       throw new LiveSageSolver.SolvingException(s"Static solver failed: unknown equations '" +
         Show(eqs) +
-//        eqs.map(Show(_)).mkString("&")+
         "' - known: "+cacheDE.keys.map(eqs => Show(eqs)).mkString(" / ") +
         " - also known: "+cacheStrDE.keys.mkString(" / "))
-  //      val instr = SageSolver.genSage(eqs)
-  //      cache += (eqs -> (s"$path/sage -c $instr".!!))
-  //      println(s"- adding ${eqs.map(Show(_)).mkString(",")} -> ${cache(eqs)}")
-
+ 
   /**
     * Throw an error if an expression was not precomputed
     * @param expr SageExpression to check if it is in cache
@@ -80,9 +77,6 @@ class StaticSageSolver extends Solver {
   def +=(expr: SyExprAll): Unit =
     if (!cacheVal.contains(expr) && !cacheStrVal.contains(Show(expr))) {
       val est = Eval(Utils.asSyExpr(expr)) // fails if expr is not a SyExpr
-//      println(s"static solver failed for ${Show(expr)}. " +
-//        s"Know only ${cacheStrVal.keys.map("'"+_+"'").mkString(", ")}. " +
-//        s"Using estimation $est instead.")
       cacheStrVal += (Show(expr) -> ((SVal(est),"")))
     }
 
@@ -95,9 +89,6 @@ class StaticSageSolver extends Solver {
   def +=(cond: Cond, valua: Valuation): Unit = {
     if (!cacheBool.contains(cond, valua) && !cacheStrBool.contains(Show(cond, valua))) {
       val est = Eval(valua.view.mapValues(Eval(_, 0)).toMap, cond)
-//      println(s"static solver failed for '${Show(cond,valua)}'. " +
-//      s"Know only ${cacheStrBool.keys.map("'"+_+"'").mkString(", ")}. " +
-//      s"Using estimation $est instead.")
       cacheStrBool += Show(cond,valua) -> (est,"")
     }
   }
@@ -134,10 +125,6 @@ class StaticSageSolver extends Solver {
 
   def ++=(systems: List[List[DiffEq]]): Unit = {
     systems.foreach(+=)
-//    val filtered = systems.filterNot(cache.contains)
-//    if (filtered.nonEmpty)
-//      throw new SageSolver.SolvingException(s"Static solver failed: unknown equations " +
-//        filtered.map(_.map(Show(_)).mkString("&")).mkString(" and "))
   }
 
   def ++=(syntax:Syntax): Unit = {
@@ -157,17 +144,19 @@ class StaticSageSolver extends Solver {
      cacheStrVal += expr -> replyToExprCache(sageReply)
 
   private def replyToExprCache(sageReply:String): ExprCache = {
+    //println("sageReply:"+sageReply)
     val resParsed = SageParser.parseExpr(sageReply)
+    //println("resParsed:"+resParsed)
     resParsed match {
       case SageParser.Success(newExpr, _) =>
-        //val fixed = Utils.fixVars(newExpr)
-        //(Eval.update(newExpr,SVal(0),Map()),sageReply)
-        (newExpr,sageReply)
+        (fixSageVars(newExpr),sageReply)
       case _: SageParser.NoSuccess =>
         throw new ParserException(s"Failed to parse Sage reply '$sageReply'.")
     }
   }
 
+  private def fixSageVars(e:SyExprAll) = e
+
   /**
     * Import the reply from Sage from evaluating a boolean expression
     */
@@ -198,35 +187,51 @@ class StaticSageSolver extends Solver {
   def importDiffEqs(eqs:List[List[DiffEq]],
                     sageReply:Iterable[String]): Unit =
     for ((eqs, res) <- eqs.zip(sageReply)) {
-      //debug(()=>s"- adding  ${eqs} -> $res")
       importDiffEqs(eqs,res)
     }
 
   def importDiffEqs (eqs:List[DiffEq], sageReply:String): Unit =
     cacheDE = cacheDE + (eqs ->
-      replyToDiffCache(Solver.getVars(eqs).filterNot(_.startsWith("_")),sageReply))
+      replyToDiffCache(returnVars(eqs),sageReply))
+  
+  //NEW 
+  def returnVars (eqs:List[DiffEq]): List[String] ={
+    println("eqs:",eqs)
+    var vars= Solver.getVars(eqs)
+    println ("Vars:",vars)
+    var filterVars=vars.filter(_.startsWith("_"))
+    println("filterVars:",filterVars)
+    var reducefilterVars=filterVars.toSet.toList
+    return reducefilterVars
+  }
 
   def importDiffEqs(eqs:String, sageReply:String): Unit =
     cacheStrDE = cacheStrDE + (eqs ->
       replyToDiffCache(findVars(eqs),sageReply))
 
   private def findVars(str: String) = {
-    //    """Var\([a-zA-Z0-9_]*\)""".r.findAllIn(str).map(_.drop(4).dropRight(1)).toList
-    val res1 = """[a-z][a-zA-Z0-9_]*\(0\)""".r.findAllIn(str).map(_.dropRight(3)).toList
-    val res2 = """[a-z][a-zA-Z0-9_]*'""".r.findAllIn(str).map(_.dropRight(1)).toList
+    val res1 = """_[a-z][a-zA-Z0-9_]*\(0\)""".r.findAllIn(str).map(_.dropRight(3)).toList
+      .filter(x => x!="sin" && x!="cos")
+    val res2 = """_[a-z][a-zA-Z0-9_]*'""".r.findAllIn(str).map(_.dropRight(1)).toList
     val res = res1++res2
-    //debug(()=>s"### finding variables in $str - found $res")
     res
   }
 
   def replyToDiffCache(vars:List[String], sageReply:String): DiffCache = {
+    println("vars:",vars)
+    println("sageReply:",sageReply)
+    println("SageParser:",SageParser.parseSol(sageReply))
+
     if (sageReply.nonEmpty) {
       val resParsed = SageParser.parseSol(sageReply) match {
         // single solution - name is not known from the answer of Sage
         case SageParser.Success(sol, _) if sol.keySet == Set("") =>
-//          val vars = Solver.getVars(eqs).filterNot(_.startsWith("_"))
           vars match {
-            case List(variable) => Map(variable -> Utils.fixVars(sol("")))
+            case List(variable) => {
+              println("sol():",sol(""))
+              println(" Map(variable -> Utils.fixVars(sol())):", Map(variable -> Utils.fixVars(sol(""))))
+              Map(variable -> Utils.fixVars(sol("")))
+            }
             case _ => throw new ParserException(s"Failed to parse $sageReply - " +
               s"only one variable expected, but found [${vars.mkString(",")}].")
           }
@@ -235,6 +240,7 @@ class StaticSageSolver extends Solver {
           result.view.mapValues(Utils.fixVars).toMap
         case _: SageParser.NoSuccess => throw new ParserException(s"Failed to parse '$sageReply'.")
       }
+     // println("resParsed:"+resParsed)
       (resParsed,sageReply)
     }
     else
@@ -249,31 +255,22 @@ class StaticSageSolver extends Solver {
     */
   def exportAll: String =
     (cacheDE-Nil)
-//      .toList.sortWith((p1,p2)=>lt(p1._1,p2._1))
       .map(it => Show(it._1) +"§"+it._2._2).mkString("§§") +
     cacheStrDE
       .map(it => it._1+"§"+it._2._2).mkString("§§") +
     "§§§" +
       cacheVal
-        //      .toList.sortWith((e1,e2)=>lt(e1._1,e2._1))
         .map(it => Show(it._1)+"§"+it._2._2).mkString("§§") +
       cacheStrVal
         .map(it => it._1+"§"+it._2._2).mkString("§§") +
     "§§§" +
     cacheBool
-//      .toList.sortWith((e1,e2)=>lt(e1._1,e2._1))
       .map(it => Show(it._1._1,it._1._2)+"§"+it._2._2).mkString("§§") +
     cacheStrBool
       .map(it => it._1+"§"+it._2._2).mkString("§§") +
     "§§§" +
      warnings.map(kv => s"${Show(kv._1)}§${kv._2}").mkString("§§")
 
-
-  //  private def lt(eqs1:List[DiffEq],eqs2:List[DiffEq]): Boolean =
-//    eqs1.mkString < eqs2.mkString
-//  private def lt(e1:SageExpr,e2:SageExpr): Boolean =
-//    e1.toString < e2.toString
-
   /**
     * Loads replies compiled with "exportAll", knowing the equations and expressions
     */
@@ -318,7 +315,7 @@ class StaticSageSolver extends Solver {
   }
 
   protected def debug(s:()=>String): Unit = {
-    // println("[Solver] "+s())
+    println(s())
   }
 
 }
diff --git a/src/main/scala/hprog/lang/Parser.scala b/src/main/scala/hprog/lang/Parser.scala
old mode 100644
new mode 100755
index cf62348..31cdf38
--- a/src/main/scala/hprog/lang/Parser.scala
+++ b/src/main/scala/hprog/lang/Parser.scala
@@ -1,268 +1,558 @@
-package hprog.lang
-
-import hprog.ast._
-import hprog.ast.SymbolicExpr.SyExprVar
-import hprog.common.ParserException
-import hprog.frontend.Utils
-
-import scala.util.matching.Regex
-import scala.util.parsing.combinator._
-
-/**
-  * Parser for Hybrid Programs, using parsing combinators.
-  * Created by jose on 19/07/2018.
-  */
-object Parser extends RegexParsers {
-
-  /**
-    * Main function that parses a string.
-    *
-    * @param c string representing a program
-    * @return Parse result (parsed(connector) or failure(error))
-    */
-  def parse(c: String): ParseResult[Syntax] = parseAll(progP, c)
-
-  /**
-    * Main function that parses a string into a Condition.
-    *
-    * @param c string representing the condition
-    * @return Parse result (parsed(cond) or failure(error))
-    */
-  def parseCond(c: String): ParseResult[Cond] = parseAll(condP, c)
-
-  //  def pexp(c:String): ParseResult[Cond] = parseAll(condP,c)
-
-  override def skipWhitespace = true
-
-  override val whiteSpace: Regex = "( |\t|\r|\f|\n|//.*)+".r
-  val identifier: Parser[String] = """[a-z][a-zA-Z0-9_]*""".r
-  val identifierCap: Parser[String] = """[a-zA-Z][a-zA-Z0-9_]*""".r
-  val nameP: Parser[String] = "[a-zA-Z0-9.-_!$]+".r
-
-  val skip = Atomic(Nil,DiffEqs(Nil,For(Value(0))))
-
-  //   ///////////////
-  //   /// Program ///
-  //   ///////////////
-  /** Parser for a program that checks if the program is closed before returning. */
-  lazy val progP: Parser[Syntax] =
-    seqP ^^ { stx =>
-      Utils.isClosed(stx) match {
-        case Left(msg) => throw new ParserException(msg)
-        case Right(_) => stx
-      }
-    }
-
-  /** Parser for a sequence of programs */
-  lazy val seqP: Parser[Syntax] =
-    basicProg ~ opt(seqP) ^^ {
-      case p1 ~ Some(p2) => p1 ~ p2
-      case p ~ None => p
-    }
-
-  /** Parser for a basic program: "skip", "while", "repeat", "if", "wait", or an atomic program (see below) */
-  lazy val basicProg: Parser[Syntax] =
-    "skip" ~> opt("for"~>realP) <~ ";" ^^ {
-      case None => skip
-      case Some(real) => Atomic(Nil,DiffEqs(Nil,For(Value(real))))
-    } |
-    "while" ~> whileGuard ~ "do" ~ "{" ~ seqP ~ "}" ^^ {
-      case c ~ _ ~ _ ~ p ~ _ => While(skip, c, p)
-    } |
-    "repeat" ~> intPP ~ "{" ~ seqP ~ "}" ^^ {
-      case c ~ _ ~ p ~ _ => While(skip, Counter(c), p)
-    } |
-    "if" ~> condP ~ "then" ~ blockP ~ "else" ~ blockP ^^ {
-      case c ~ _ ~ p1 ~ _ ~ p2 => ITE(c, p1, p2)
-    } |
-    ("wait"~>linP) <~ ";" ^^ {
-      time => Atomic(Nil,DiffEqs(Nil,For(time)))
-    }|
-    atomP
-
-  /** parser of a program wrapped with curly brackets or a basic program */
-  lazy val blockP: Parser[Syntax] =
-    "{"~>seqP<~"}" |
-    basicProg
-
-  /** Parser for the guard of a while loop (a condition of an integer) */
-  lazy val whileGuard: Parser[LoopGuard] = {
-    condP ^^ Guard |
-    intPP ^^ Counter
-  }
-
-  /** Parser for an atomic program: an assignment or a set of diff equations. */
-  lazy val atomP: Parser[Atomic] =
-    (identifier ~ ":=" ~ linP) <~ ";" ^^ {
-      case v ~ _ ~ l => Atomic(List(Assign(Var(v), l)),DiffEqs(Nil,For(Value(0))))
-    } |
-    (diffEqsP ~ opt(durP)) <~ ";" ^^ {
-      case des ~ d => Atomic(Nil,des & d.getOrElse(Forever))
-    }
-
-  /** Parser for  differential equations */
-  lazy val diffEqsP: Parser[DiffEqs] =
-    identifier ~ "'" ~ "=" ~ linP ~ opt("," ~> diffEqsP) ^^ {
-      case v ~ _ ~ _ ~ l ~ Some(eqs) => DiffEqs(List(Var(v) ^= l), Forever) & eqs
-      case v ~ _ ~ _ ~ l ~ None => DiffEqs(List(Var(v) ^= l), Forever)
-    }
-
-  /** Parser for the duration part ("until" or "for") after the differential equations */
-  lazy val durP: Parser[Dur] =
-    "until" ~ opt(untilArgs) ~ condP ^^ {
-      case _ ~ None ~ cond => Until(cond,None /*0.01*/,None)
-      case _ ~ Some(args) ~ cond => Until(cond,Some(args._1),args._2)
-    } |
-    "for" ~> linP ^^ For
-             //realP ^^ Value.andThen(For)
-
-  /** Parser for the arguments of an "until" block (after diff equations)  */
-  lazy val untilArgs:Parser[(Double,Option[Double])] =
-    "_"~realP~opt(","~>realP) ^^ {
-      case _~eps~jump => (eps,jump)
-    }
-
-  //////////
-
-  /** Parser for a linear integer expression */
-  lazy val linP: Parser[Lin] =
-    linParcelP ~opt(("+"~>linP)|("-"~>negLinP)) ^^ {
-      case l1~Some(l2) => l1+l2
-      case l1~_        => l1
-    }
-  private lazy val negLinP: Parser[Lin] =
-    linParcelP ~opt(("+"~>linP)|("-"~>negLinP)) ^^ {
-      case l1~Some(l2) => invert(l1)+l2
-      case l1~_        => invert(l1)
-  }
-
-  /** Parser for a parcel (element being added/subtracted) */
-  lazy val linParcelP: Parser[Lin] =
-    "-"~>linMultP ^^ invert |
-    linMultP
-
-
-//  lazy val linP: Parser[Lin] =
-//    opt("-") ~ linLitP ~ opt(linContP) ^^ {
-//      case sign ~ l1 ~ Some(l2) => mbInvert(sign, l1) + l2
-//      case sign ~ l1 ~ _        => mbInvert(sign, l1)
-//    }
-//  // r*var | r*(..) | var*r | (..)*r | r | var | (...)
-
-  /** Parser for the multiplication of atomic values (real, variables, or
-    * linear expressions), guaranteeing the result is a linear expression:
-    * multiplications must have a real in one of its sides. */
-  lazy val linMultP: Parser[Lin] = //...r | r*linAt | var*r |
-    realP ~ opt("*"~>linAtP) ^^ {
-      case r ~ Some(l) => Mult(Value(r),l)
-      case r ~ _ => Value(r)
-    } |
-    linAtP ~ opt("*"~>realP) ^^ {
-      case l ~ Some(r) => Mult(Value(r),l)
-      case l ~ _ => l
-    }
-  /** Atomic linear expression is a variable or a linear expression */
-  lazy val linAtP: Parser[Lin] =
-    identifier ^^ Var |
-    "("~>linP<~")"
-
-/////////////////
-
-  //  lazy val linP: Parser[Lin] =
-//    opt("-") ~ identifier ~ opt(linVarContP) ^^ {
-//      case sign ~ vr ~ f => mbInvert(sign,f.getOrElse((x: Var) => x)(Var(vr)))
-//    } |
-//    opt("-") ~ realP ~ opt(linValContP) ^^ {
-//      case sign ~ vl ~ f => mbInvert(sign,f.getOrElse((x: Value) => x)(Value(vl)))
-//    } |
-//    "(" ~> linP <~ ")"
-//
-//  lazy val linVarContP: Parser[Var => Lin] =
-//    "-" ~> linP ^^ { l => v: Var => v + invert(l) } |
-//    "+" ~> linP ^^ { l => v: Var => v + l } |
-//    "*" ~> realP ^^ { r => v: Var => Value(r) * v }
-//  lazy val linValContP: Parser[Value => Lin] =
-//    "-" ~> linP ^^ { l => v: Value => v + invert(l) } |
-//    "+" ~> linP ^^ { l => v: Value => v + l } |
-//    "*" ~> linP ^^ { l => v: Value => v * l }
-
-  /** Parser for a boolean expression with variables as a possible conjunction of `disjP` */
-  lazy val condP: Parser[Cond] =
-    disjP ~ opt("/\\" ~> condP) ^^ {
-      case e1 ~ Some(e2) => e1 && e2
-      case e1 ~ None => e1
-    }
-
-  /** Parser for a (possible) disjunction of equivalences */
-  lazy val disjP: Parser[Cond] =
-    equivP ~ opt("\\/" ~> disjP) ^^ {
-      case e1 ~ Some(e2) => e1 || e2
-      case e1 ~ None => e1
-    }
-
-  /** Parser for a (possible) equivalence (via "<->") of simpler conditions */
-  lazy val equivP: Parser[Cond] =
-    negP ~ opt("<->" ~> equivP) ^^ {
-      case e1 ~ Some(e2) => e1 || e2
-      case e1 ~ None => e1
-    } //|
-  //     "("~equivP~")" ^^ { case _~e~_ => e }
-  /** Parser of a (possibly negated) block of a condition or a literal or inequality `bopP` */
-  lazy val negP: Parser[Cond] =
-    "!" ~ "(" ~> condP <~ ")" ^^ Not |
-      //    "!"~>litP ^^ Not |
-      "(" ~> condP <~ ")" |
-      bopP
-
-  //  lazy val litP: Parser[Cond] =
-  //    identifierOrBool
-  //
-  /** Parser for a literal (true/false/var) or an inequality (var<=exp) */
-  lazy val bopP: Parser[Cond] =
-    identifier ~ opt(bcontP) ^? ( {
-      case "true" ~ None => BVal(true)
-      case "false" ~ None => BVal(false)
-      case e ~ Some(co) => co(Var(e))
-    }: PartialFunction[String ~ Option[Var=>Cond],Cond],
-    {
-      case e ~ _ => s"Not a condition: $e"
-    })
-
-  /** Parser for an inequality of (linear) integer expressions */
-  lazy val bcontP: Parser[Var => Cond] =
-    "<=" ~> linP ^^ (e2 => (e1: Var) => e1 <= e2) |
-    ">=" ~> linP ^^ (e2 => (e1: Var) => e1 >= e2) |
-    "<" ~> linP ^^ (e2 => (e1: Var) => e1 < e2) |
-    ">" ~> linP ^^ (e2 => (e1: Var) => e1 > e2) |
-    "==" ~> linP ^^ (e2 => (e1: Var) => e1 === e2) |
-    "!=" ~> linP ^^ (e2 => (e1: Var) => Not(e1 === e2))
-
-
-  /** Parsr for a real number */
-  lazy val realP: Parser[Double] =
-    """-?[0-9]+(\.([0-9]+))?""".r ^^ { s: String => s.toDouble }
-
-  /** Parser for an integer number, possibly with parenthesis */
-  lazy val intPP: Parser[Int] =
-    "("~>intP<~")" |
-    intP
-  /** Parser for an integer number  */
-  lazy val intP: Parser[Int] =
-    """[0-9]+""".r ^^ { s: String => s.toInt }
-
-//  def intExpr: Parser[SyExprVar] =
-//    SageParser.eqExpr ^^ { Utils.asSyExprVar } // assuming it has no variable "_t_"
-
-  /** Auxiliary: function that negates a (linear) integer expression */
-  private def invert(lin: Lin): Lin = lin match {
-    case Var(v) =>  Mult(Value(-1),Var(v))
-    case Value(v) => Value(-v)
-    case Add(l1, l2) => Add(invert(l1),invert(l2))
-    case Mult(Value(v), l) => Mult(Value(-v),l)
-  }
-  /** Auxiliary: experimental function that also negates a (linear)
-    * integer expression, possibly avoiding negation.   */
-  private def mbInvert(sign:Option[_],lin:Lin): Lin =
-    if (sign.isDefined) invert(lin) else lin
-}
-
+
+package hprog.lang
+
+import hprog.ast._
+import Syntax._
+import hprog.ast.SymbolicExpr.SyExprVar
+import hprog.common.ParserException
+import hprog.frontend.Utils
+
+import scala.util.matching.Regex
+import scala.util.parsing.combinator._
+import scala.math._
+
+/**
+  * Parser for Hybrid Programs, using parsing combinators.
+  * Created by Ricardo and José in 31/1/23.
+  */
+
+
+// It will take a set of characters and return the corresponding Syntax
+object Parser extends RegexParsers {
+
+  /**
+    * Main function that parses a string.
+    *
+    * @param c string representing a program
+    * @return Parse result (parsed(connector) or failure(error))
+    */
+  def parse(c: String): ParseResult[Syntax] = parseAll(progP, c)
+
+  /**
+    * Main function that parses a string into a Condition.
+    *
+    * @param c string representing the condition
+    * @return Parse result (parsed(cond) or failure(error))
+    */
+  def parseCond(c: String): ParseResult[Cond] = parseAll(condP, c)
+
+
+  override def skipWhitespace = true
+
+  override val whiteSpace: Regex = "( |\t|\r|\f|\n|//.*)+".r
+  val identifier: Parser[String] = """[a-z][a-zA-Z0-9_]*""".r
+  val identifierCap: Parser[String] = """[a-zA-Z][a-zA-Z0-9_]*""".r
+  val nameP: Parser[String] = "[a-zA-Z0-9.-_!$]+".r
+
+  val skip = Atomic(Nil, DiffEqs(Nil, For(ValueNotLin(0))))
+
+  //   ///////////////
+  //   /// Program ///
+  //   ///////////////
+
+  /** Parser for a program that checks if the program is closed before returning. */
+
+
+  lazy val progP: Parser[Syntax] =
+    seqP ^^ { stx =>
+      Utils.isClosed(stx) match {
+        case Left(msg) => throw new ParserException(msg)
+        case Right(_) => {
+          //var aux:Map[String,NotLin]=Map()
+          //var x=Utils.updateSyntax(stx,aux,0,Utils.extractVarsDifEqs(stx),0)
+          //x._1
+          stx
+        }
+      }
+    }
+
+
+
+
+  //lazy val progP: Parser[Syntax] = seqP
+
+
+  // Parser to obligate program to have a atomic/s (declarations of variables) followed by instructions
+  lazy val seqP: Parser[Syntax] =
+    atomP ~ opt(nextInstructions) ^^ {
+      case a ~ Some(n) => a ~ n
+      case a ~ None => a
+    }
+
+
+  // instructions or sequence of instructions
+  lazy val nextInstructions: Parser[Syntax] =
+    basicProg ~ opt(nextInstructions) ^^ {
+      case p1 ~ Some(p2) => p1 ~ p2
+      case p ~ None => p
+    }
+
+  /** Parser for a basic program: "skip", "while", "repeat", "if", "wait", or an atomic program (see below) */
+  lazy val basicProg: Parser[Syntax] =
+    "skip" ~> opt("for" ~> realP) <~ ";" ^^ {
+      case None => skip
+      case Some(real) => Atomic(Nil, DiffEqs(Nil, For(ValueNotLin(real))))
+    } |
+      "while" ~> whileGuard ~ "do" ~ "{" ~ nextInstructions ~ "}" ^^ {
+        case c ~ _ ~ _ ~ p ~ _ => While(skip, c, p)
+      } |
+      "repeat" ~> intPP ~ "{" ~ nextInstructions ~ "}" ^^ {
+        case c ~ _ ~ p ~ _ => While(skip, Counter(c), p)
+
+      } |
+      "if" ~> condP ~ "then" ~ blockP ~ "else" ~ blockP ^^ {
+        case c ~ _ ~ p1 ~ _ ~ p2 => ITE(c, p1, p2)
+      } |
+      ("wait" ~> notlinP) <~ ";" ^^ {
+        time => Atomic(Nil, DiffEqs(Nil, For(time)))
+      } |
+      atomP
+
+
+  /** parser of a program wrapped with curly brackets or a basic program */
+  lazy val blockP: Parser[Syntax] =
+    "{" ~> nextInstructions <~ "}" |
+      basicProg
+
+  /** Parser for the guard of a while loop (a condition of an integer) */
+  lazy val whileGuard: Parser[LoopGuard] = {
+    condP ^^ Guard |
+      intPP ^^ Counter
+  }
+
+  /** Parser for an atomic program: an assignment or a set of diff equations. */
+  lazy val atomP: Parser[Atomic] =
+    (identifier ~ ":=" ~ notlinP) <~ ";" ^^ {
+      case v ~ _ ~ l => Atomic(List(Assign(VarNotLin("_" + v), l)), DiffEqs(Nil, For(ValueNotLin(0))))
+    } |
+      (diffEqsP ~ opt(durP)) <~ ";" ^^ {
+        case des ~ d => Atomic(Nil, des & d.getOrElse(Forever))
+      } |
+      durP <~ ";" ^^ {
+        case d => Atomic(Nil, DiffEqs(Nil, d)) // upgrate
+      }
+
+
+  /** Parser for  differential equations */
+  lazy val diffEqsP: Parser[DiffEqs] =
+    identifier ~ "'" ~ "=" ~ notlinP ~ opt("," ~> diffEqsP) ^^ {
+      case v ~ _ ~ _ ~ l ~ Some(eqs) => DiffEqs(List(VarNotLin("_" + v) ^= l), Forever) & eqs
+      case v ~ _ ~ _ ~ l ~ None => DiffEqs(List(VarNotLin("_" + v) ^= l), Forever)
+    }
+
+  /** Parser for the duration part ("until" or "for") after the differential equations */
+  lazy val durP: Parser[Dur] =
+    "until" ~ opt(untilArgs) ~ condP ^^ {
+      case _ ~ None ~ cond => Until(cond, None /*0.01*/ , None)
+      case _ ~ Some(args) ~ cond => Until(cond, Some(args._1), args._2)
+    } |
+      "for" ~> notlinP ^^ For
+
+  /** Parser for the arguments of an "until" block (after diff equations) */
+  lazy val untilArgs: Parser[(Double, Option[Double])] =
+    "_" ~ realP ~ opt("," ~> realP) ^^ {
+      case _ ~ eps ~ jump => (eps, jump)
+    }
+
+
+
+
+
+
+  ///////////////////// non linear expressions /////////////////////////////
+
+  lazy val notlinP: Parser[NotLin] =
+    notlinParcelP ~ opt(("+" ~> notlinP) | ("-" ~> negnotLinP)) ^^ {
+      case l1 ~ Some(l2) => l1 + l2
+      case l1 ~ _ => l1
+
+    }
+
+  private lazy val negnotLinP: Parser[NotLin] =
+    notlinParcelP ~ opt(("+" ~> notlinP) | ("-" ~> negnotLinP)) ^^ {
+      case l1 ~ Some(l2) => invertNotLin(l1) + l2
+      case l1 ~ _ => invertNotLin(l1)
+    }
+
+  lazy val notlinParcelP: Parser[NotLin] =
+    "-" ~> notlinMultP ^^ invertNotLin |
+      notlinMultP
+
+
+  lazy val notlinMultP: Parser[NotLin] =
+    notlinDivP ~ opt("*" ~> notlinMultP) ^^ {
+      case l1 ~ Some(l2) => MultNotLin(l1, l2)
+      case l1 ~ None => l1
+
+    }
+
+  lazy val notlinDivP: Parser[NotLin] =
+    notlinResP ~ opt("/" ~> notlinDivP) ^^ {
+      case l1 ~ Some(l2) => DivNotLin(l1, l2)
+      case l1 ~ None => l1
+
+    }
+
+
+  lazy val notlinResP: Parser[NotLin] =
+    notlinAtP ~ opt("%" ~> notlinResP) ^^ {
+      case l1 ~ Some(l2) => ResNotLin(l1, l2)
+      case l1 ~ None => l1
+
+    }
+
+
+
+  /*
+  lazy val notlinAtP: Parser[NotLin] =
+    "pi" ~ "(" ~ ")" ^^ {
+      case _ ~ _ ~ _=> FuncNotLin("PI",List())
+    }|
+    "e" ~ "(" ~ ")" ~ opt("^" ~> notlinOthers)^^ {
+      case _ ~ _ ~ _ ~ None => FuncNotLin("E",List())
+      case _ ~ _ ~ _ ~ Some(l1) => FuncNotLin("exp",List(l1))
+    }|
+    "pow" ~ "(" ~ notlinOthers ~ "," ~ notlinOthers ~ ")" ^^{
+      case _ ~ _ ~ l1 ~ _ ~ l2 ~ _=> PowNotLin(l1,l2)
+    }|
+     notlinOthers ~ opt("^" ~>  notlinOthers)  ^^{
+      case l1 ~ Some(l2) => PowNotLin(l1,l2)
+      case l1 ~ _ => l1
+    }
+
+  lazy val notlinOthers: Parser[NotLin]=
+    realP ^^ {
+      ValueNotLin
+    }|
+    identifier ~ opt("("~>argsFunction<~")") ^^{
+      case s ~ Some(arguments) => FuncNotLin(s,arguments)
+      case s ~ _ => VarNotLin (s)
+    }|
+    "("~>notlinP<~")" ^^ {
+      case l => l
+    }
+*/
+
+
+  lazy val notlinAtP: Parser[NotLin] =
+    notlinOthers ~ "^" ~ notlinOthers ^^ {
+      case l1 ~ _ ~ l2 => PowNotLin(l1, l2)
+    } |
+      notlinOthers
+
+
+  lazy val notlinOthers: Parser[NotLin] =
+    "pi" ~ "(" ~ ")" ~ opt("^" ~> notlinOthers) ^^ {
+      case _ ~ _ ~ _ ~ None => PowNotLin(FuncNotLin("PI", List()), ValueNotLin(1)) //mitigate numetical errors
+      case _ ~ _ ~ _ ~ Some(l1) => PowNotLin(FuncNotLin("PI", List()), l1)
+    } |
+      "e" ~ "(" ~ ")" ~ opt("^" ~> notlinOthers) ^^ {
+        case _ ~ _ ~ _ ~ None => PowNotLin(FuncNotLin("E", List()), ValueNotLin(1)) //mitigate numetical errors
+        case _ ~ _ ~ _ ~ Some(l1) => FuncNotLin("exp", List(l1))
+      } |
+      "pow" ~ "(" ~ notlinP ~ "," ~ notlinP ~ ")" ^^ {
+        case _ ~ _ ~ l1 ~ _ ~ l2 ~ _ => PowNotLin(l1, l2)
+      } |
+      realP ^^ {
+        ValueNotLin
+      } |
+      identifier ~ opt("(" ~> argsFunction <~ ")") ^^ {
+        case s ~ Some(arguments) => FuncNotLin(s, arguments)
+        case s ~ _ => VarNotLin("_" + s)
+      } |
+      "(" ~> notlinP <~ ")" ^^ {
+        case l => l
+      }
+
+
+  lazy val argsFunction: Parser[List[NotLin]] =
+    notlinP ~ opt("," ~> argsFunction) ^^ {
+      case n ~ Some(ns) => n :: ns
+      case n ~ _ => List(n)
+    }
+
+
+
+
+  /*
+  ////////// linear expression ///////////////
+  lazy val linP: Parser[Lin] =
+    linParcelP ~opt(("+"~>linP)|("-"~>negLinP)) ^^ {
+      case l1~Some(l2) => l1+l2
+      case l1~_        => l1
+    }
+  private lazy val negLinP: Parser[Lin] =
+    linParcelP ~opt(("+"~>linP)|("-"~>negLinP)) ^^ {
+      case l1~Some(l2) => invert(l1)+l2
+      case l1~_        => invert(l1)
+  }
+/** Parser for a parcel (element being added/subtracted) */
+  lazy val linParcelP: Parser[Lin] =
+    "-"~>linMultP ^^ invert |
+    linMultP
+  lazy val linMultP: Parser[Lin] =  
+    seqRealIdentP 
+ 
+  lazy val seqRealIdentP: Parser[Lin]=
+    seqRealIdentATP ~ opt("*"~>seqRealIdentP) ^^{
+      case s ~ None => s
+      case s ~ Some(l) => Mult(s,l)
+    } 
+  lazy val seqRealIdentATP:Parser[Lin]=
+    realP ^^ Value|
+    identifier ^^ Var|
+    "("~>linP<~")"
+*/
+
+
+  /*
+  /** Parser for the multiplication of atomic values (real, variable, or
+    * linear expressions), guaranteeing the result is a linear expression:
+    * multiplications must have a real (just a real number or a result of an expression) in one of its sides, or in both. */
+  lazy val linMultP: Parser[Lin] = 
+    opt(seqRealP <~ "*")  ~  linAtP ~ opt(seqMultDiv) ^^ {
+      case None  ~ l ~ None => l
+      case Some(s1) ~ l ~ None => Mult(Value(s1),l)
+      case None  ~ l ~ Some(s1) => Mult(Value(s1),l)
+      case Some(s1) ~ l ~ Some(s2) => Mult(Value(s1*s2),l)
+    } 
+  
+  /** Atomic linear expression is a variable, a real (just a real number or a result of an expression) or a linear expression */
+  lazy val linAtP: Parser[Lin] =
+    identifier ^^ Var |
+    realP ^^ Value |
+    "("~>linP<~")" 
+    //realP ^^ Value |
+// Sequence of a multiplication/division of a real expressions in the right side of the atomic values
+lazy val seqMultDiv:Parser[Double]=
+  "*" ~ reallinAtP ~ opt(seqMultDiv) ^^ {
+    case _ ~ r ~ None => r
+    case _ ~ r ~ Some(s) => r*s
+  } |
+  "/" ~ reallinAtP ~ opt(seqMultDiv) ^^ {
+    case _ ~ r ~ None => 1/r
+    case _ ~ r ~ Some(s) => (1/r)*s
+  } |
+  "*" ~ "(" ~ realLinP ~ ")" ~ opt(seqMultDiv) ^^ {
+    case _ ~ _ ~ r ~ _ ~ None => r
+    case _ ~ _ ~ r ~ _ ~ Some(s)  => r*s
+  } |
+  "/" ~ "(" ~ realLinP ~ ")" ~ opt(seqMultDiv) ^^ {
+    case _ ~ _ ~ r ~ _ ~ None => 1/r
+    case _ ~ _ ~ r ~ _ ~ Some(s)  => (1/r)*s
+  }
+// // Sequence of a multiplication/division of a real expressions in the left side of the atomic values
+lazy val seqRealP:Parser[Double]=
+   reallinAtP ~ opt(seqMultDiv) ^^ {
+    case r ~ None => r
+    case r ~ Some(s) => r*s
+   }
+// Parser of real expressions
+lazy val realLinP: Parser[Double]=
+  reallinParcelP ~opt(("+"~>realLinP)|("-"~>realnegLinP)) ^^ {
+  case l1~Some(l2) => l1+l2
+  case l1~_        => l1
+}
+private lazy val realnegLinP: Parser[Double] =
+reallinParcelP ~opt(("+"~>realLinP)|("-"~>realnegLinP)) ^^ {
+  case l1~Some(l2) => -l1+l2
+  case l1~_        => -l1
+}
+lazy val reallinParcelP: Parser[Double] =
+  "-"~>reallinMultP ^^ {
+   case r => -r
+  }|
+  reallinMultP
+lazy val reallinMultP: Parser[Double] = 
+    reallinDivP ~ opt("*"~>reallinMultP) ^^ {
+      case l1 ~ Some(l2) => l1*l2
+      case l1 ~ None => l1
+      
+    } 
+  lazy val reallinDivP: Parser[Double] = 
+    reallinResP ~ opt("/"~>reallinDivP) ^^ {
+      case l1 ~ Some(l2) => l1/l2
+      case l1 ~ None => l1
+      
+    }
+  lazy val reallinResP: Parser[Double] = 
+    reallinAtP ~ opt("%"~>reallinResP) ^^ {
+      case l1 ~ Some(l2) => l1%l2
+      case l1 ~ None => l1
+      
+    } 
+    
+ 
+ // atomics of the real expressions
+  lazy val reallinAtP: Parser[Double] =
+    "pi" ~ "(" ~ ")" ^^ {
+      case _ ~ _ ~ _=> math.Pi
+    }|
+    opt("-") ~ "e" ~ "(" ~ ")" ~ opt("^" ~> reallinOthers)^^ {
+      case None ~ _ ~ _ ~ _ ~ None => math.E
+      case None ~ _ ~ _ ~ _ ~ Some(l1) => math.exp(l1)
+      case Some(_) ~ _ ~ _ ~ _ ~ None => - math.E 
+      case Some(_) ~ _ ~ _ ~ _ ~ Some(l1) => - math.exp(l1)
+    }|
+    opt("-") ~ "pow" ~ "(" ~ reallinOthers ~ "," ~ reallinOthers ~ ")" ^^{
+      case None ~ _ ~ _ ~ l1 ~ _ ~ l2 ~ _=> math.pow(l1,l2)
+      case Some(_) ~ _ ~ _ ~ l1 ~ _ ~ l2 ~ _=> - math.pow(l1,l2)
+    }|
+     opt("-") ~ reallinOthers ~ opt("^" ~>  reallinOthers)  ^^{
+      case None ~ l1 ~ Some(l2) => math.pow(l1,l2)
+      case None ~ l1 ~ None => l1
+      case Some(_) ~ l1 ~ None => -l1
+      case Some(_) ~ l1 ~ Some(l2) => -math.pow(l1,l2)
+    } 
+  lazy val reallinOthers: Parser[Double]=
+    realP|
+    "sin" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.sin(r)
+    }|
+    "cos" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.cos(r)
+    }|
+    "tan" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.tan(r)
+    }|
+    "arcsin" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.asin(r)
+    }|
+    "arccos" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.acos(r)
+    }|
+    "arctan" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.atan(r)
+    }|
+    "sinh" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.sinh(r)
+    }|
+    "cosh" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.cosh(r)
+    }|
+    "tanh" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.tanh(r)
+    }|
+    "sqrt" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.sqrt(r)
+    }|
+    "log" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.log(r)
+    }|
+    "log10" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.log10(r)
+    }|
+    "max" ~ "(" ~ realLinP ~ "," ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r1 ~ _ ~ r2 ~ _ => math.max(r1,r2)
+    }|
+    "min" ~ "(" ~ realLinP ~ "," ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r1 ~ _ ~ r2 ~ _ => math.min(r1,r2)
+    }|
+    "exp" ~ "(" ~ realLinP ~ ")" ^^ {
+      case _ ~ _ ~ r ~ _ => math.exp(r)
+    }|
+    "("~>realLinP<~")" ^^ {
+      case l => l
+    }  
+  */
+
+  //////////////////// Conditions //////////////////////////////////////////
+
+  lazy val condP: Parser[Cond] =
+    disjP ~ opt("&&" ~> condP) ^^ {
+      case e1 ~ Some(e2) => e1 && e2
+      case e1 ~ None => e1
+    }
+
+  /** Parser for a (possible) disjunction of equivalences */
+  lazy val disjP: Parser[Cond] =
+    equivP ~ opt("||" ~> disjP) ^^ {
+      case e1 ~ Some(e2) => e1 || e2
+      case e1 ~ None => e1
+    }
+
+
+  /** Parser for a (possible) equivalence (via "<->") of simpler conditions */
+  lazy val equivP: Parser[Cond] =
+    negP ~ opt("<=>" ~> equivP) ^^ {
+      case e1 ~ Some(e2) => e1 || e2
+      case e1 ~ None => e1
+    }
+  /** Parser of a (possibly negated) block of a condition or a literal or inequality `bopP` */
+  lazy val negP: Parser[Cond] =
+    "!" ~ "(" ~> condP <~ ")" ^^ Not |
+      bopP |
+      "(" ~> condP <~ ")" |
+      condP
+
+
+  lazy val bopP: Parser[Cond] =
+    "true" ^^ {
+      case _ => BVal(true)
+    } |
+      "false" ^^ {
+        case _ => BVal(false)
+      } |
+      notlinP ~ "<=" ~ notlinP ^^ {
+        case l1 ~ _ ~ l2 => LE(l1, l2)
+      } |
+      notlinP ~ ">=" ~ notlinP ^^ {
+        case l1 ~ _ ~ l2 => GE(l1, l2)
+      } |
+      notlinP ~ "<" ~ notlinP ^^ {
+        case l1 ~ _ ~ l2 => LT(l1, l2)
+      } |
+      notlinP ~ ">" ~ notlinP ^^ {
+        case l1 ~ _ ~ l2 => GT(l1, l2)
+      } |
+      notlinP ~ "==" ~ notlinP ^^ {
+        case l1 ~ _ ~ l2 => EQ(l1, l2)
+      } |
+      notlinP ~ "!=" ~ notlinP ^^ {
+        case l1 ~ _ ~ l2 => Not(EQ(l1, l2))
+      }
+
+  /** Parsr for a real number */
+  lazy val realP: Parser[Double] =
+    """-?[0-9]+(\.([0-9]+))?""".r ^^ { s: String => s.toDouble }
+
+  /** Parser for an integer number, possibly with parenthesis */
+  lazy val intPP: Parser[Int] =
+    "(" ~> intP <~ ")" |
+      intP
+  /** Parser for an integer number */
+  lazy val intP: Parser[Int] =
+    """[0-9]+""".r ^^ { s: String => s.toInt }
+
+
+  /*
+  /** Auxiliary: function that negates a (linear) integer expression */
+  private def invert(lin: Lin): Lin = lin match {
+    case Var(v) =>  Mult(Value(-1),Var(v))
+    case Value(v) => Value(-v)
+    case Add(l1, l2) => Add(invert(l1),invert(l2))
+    case Mult(l1, l2) => Mult(Mult(Value(-1),l1),l2) //new
+  }
+*/
+
+
+  /** Auxiliary: function that negates a (non linear) integer expression */
+  private def invertNotLin(lin: NotLin): NotLin = lin match {
+    case VarNotLin(v) => MultNotLin(ValueNotLin(-1), VarNotLin(v))
+    case ValueNotLin(v) => ValueNotLin(-v)
+    case AddNotLin(l1, l2) => AddNotLin(invertNotLin(l1), invertNotLin(l2))
+    case MultNotLin(l1, l2) => MultNotLin(invertNotLin(l1), l2)
+    case DivNotLin(l1, l2) => DivNotLin(invertNotLin(l1), l2)
+    case ResNotLin(l1, l2) => ResNotLin(invertNotLin(l1), l2)
+    case PowNotLin(l1, l2) => MultNotLin(ValueNotLin(-1), PowNotLin(l1, l2))
+    case FuncNotLin(s, ns) => MultNotLin(ValueNotLin(-1), FuncNotLin(s, ns))
+  }
+
+
+  /*
+  /** Auxiliary: experimental function that also negates a (linear)
+    * integer expression, possibly avoiding negation.   */
+  private def mbInvert(sign:Option[_],lin:Lin): Lin =
+    if (sign.isDefined) invert(lin) else lin
+    */
+}
\ No newline at end of file
diff --git a/src/main/scala/hprog/lang/Parser2.scala b/src/main/scala/hprog/lang/Parser2.scala
old mode 100644
new mode 100755
index 1d43581..897018e
--- a/src/main/scala/hprog/lang/Parser2.scala
+++ b/src/main/scala/hprog/lang/Parser2.scala
@@ -8,6 +8,7 @@ import cats.data.NonEmptyList
 import cats.parse.Rfc5234.sp
 
 import hprog.ast._
+import Syntax._
 import hprog.ast.SymbolicExpr.SyExprVar
 import hprog.common.ParserException
 import hprog.frontend.Utils
@@ -91,6 +92,17 @@ object Parser2 {
   def intP: P[Int] = digits.map(_.toInt)
 
   /** (Recursive) Parser for an linear expression */
+  
+
+
+
+
+
+/*
+
+//////////////////////////////////////////////////////////////////////
+// ALTEREI !!!!!!!!!!!!!!!!!!!!!
+
   def linP: P[Lin] = P.recursive((linRec:P[Lin]) => {
     def lit: P[Lin] = P.recursive((litRec:P[Lin]) => {
       char('(') *> linRec.surroundedBy(sps) <* char(')') |
@@ -104,9 +116,20 @@ object Parser2 {
         case (Value(x), l) => Mult(Value(x), l)
         case (l, Value(x)) => Mult(Value(x), l)
         case _ => sys.error(s"Multiplication [$x * $y] must have at least a fixed number.")
+        //case _ => sys.error(s"Multiplication [$x * $y] must have at least a fixed number.")
 //        case _ => P.failWith(s"Multiplication [$x * $y] must have at least a fixed number.")
       })
+    /*
+    def div: P[(Lin, Lin) => Lin] =
+      string("/").as((x:Lin,y:Lin) => (x,y) match {
+        case (l1,l2) => Div(l1,l2)
+      })
 
+    def res: P[(Lin, Lin) => Lin] =
+      string("%").as((x:Lin,y:Lin) => (x,y) match {
+        case (l1,l2) => Res(l1,l2)
+      })
+    */
     def plusminus: P[(Lin, Lin) => Lin] =
       string("+").as((x:Lin,y:Lin) => Add(x,y)) |
       string("-").as((x:Lin,y:Lin) => Add(x, Mult(Value(-1), y)))
@@ -114,6 +137,38 @@ object Parser2 {
     listSep(listSep(lit, mult), plusminus)
   })
 
+*/
+
+
+  def notlinP: P[NotLin] = P.recursive((linRec:P[NotLin]) => {
+    def litnotlin: P[NotLin] = P.recursive((litRec:P[NotLin]) => {
+      char('(') *> linRec.surroundedBy(sps) <* char(')') |
+      (char('-') ~ litRec).map(x => MultNotLin(ValueNotLin(-1), x._2)) |
+      realP.map(ValueNotLin.apply) |
+      varName.map(VarNotLin.apply)
+    })
+
+    def multnotlin: P[(NotLin, NotLin) => NotLin] =
+      string("*").as((x:NotLin,y:NotLin) => (x,y) match {
+        case (l1,l2) => MultNotLin(l1,l2)
+      })
+
+    def plusminusnotlin: P[(NotLin, NotLin) => NotLin] =
+      string("+").as((x:NotLin,y:NotLin) => AddNotLin(x,y)) |
+      string("-").as((x:NotLin,y:NotLin) => AddNotLin(x, MultNotLin(ValueNotLin(-1), y)))
+
+    listSep(listSep(litnotlin, multnotlin), plusminusnotlin)
+  })
+
+
+
+
+
+
+
+
+
+
 //  def linPNew: P[Lin] = P.recursive((linRec: P[Lin]) => {
 //    def lit: P[Lin] =
 //      char('(') *> linRec.surroundedBy(sps) <* char(')') |
@@ -147,7 +202,7 @@ object Parser2 {
 
 
   def durP: P[Dur] =
-    (string("for")~sps) *> linP.map(For.apply) |
+    (string("for")~sps) *> notlinP.map(For.apply) |
     (string("until")~(char('_')*>realP~(char(',')*>realP).?).? ~ sps ~ condP)
       .map(x => {
         val eps = x._1._1._2.map(_._1)
@@ -166,18 +221,18 @@ object Parser2 {
       char('(') *> bexprRec <* char(')')
     )
 
-    def op: P[(Lin, Lin) => Cond] =
+    def op: P[(NotLin, NotLin) => Cond] =
     //      string("<=").as((x: Lin, y: Lin) => Or(LT(x, y), EQ(x, y))) |
     //        string(">=").as((x: Lin, y: Lin) => Or(GT(x, y), EQ(x, y))) |
-      string("<=").as((x: Lin, y: Lin) => LE(x, y)) |
-      string(">=").as((x: Lin, y: Lin) => GE(x, y)) |
-      char('<').as((x:Lin,y:Lin) => LT(x,y)) |
-      char('>').as((x:Lin,y:Lin) => GT(x,y)) |
-      string("==").as((x:Lin,y:Lin) => EQ(x,y)) |
-      string("!=").as((x:Lin,y:Lin) => Not(EQ(x,y)))
+      string("<=").as((x: NotLin, y: NotLin) => LE(x, y)) |
+      string(">=").as((x: NotLin, y: NotLin) => GE(x, y)) |
+      char('<').as((x:NotLin,y:NotLin) => LT(x,y)) |
+      char('>').as((x:NotLin,y:NotLin) => GT(x,y)) |
+      string("==").as((x:NotLin,y:NotLin) => EQ(x,y)) |
+      string("!=").as((x:NotLin,y:NotLin) => Not(EQ(x,y)))
 
     def ineq =
-      (linP ~ op.surroundedBy(sps) ~ linP).map(x => x._1._2(x._1._1, x._2))
+      (notlinP ~ op.surroundedBy(sps) ~ notlinP).map(x => x._1._2(x._1._1, x._2))
 
     def or: P[(Cond, Cond) => Cond] =
       (string("||")|string("\\/")).map(_ => Or.apply)
@@ -229,14 +284,14 @@ object Parser2 {
 //      })
   })
 
-  val skipComm: Syntax = Atomic(Nil, DiffEqs(Nil, For(Value(0))))
+  val skipComm: Syntax = Atomic(Nil, DiffEqs(Nil, For(ValueNotLin(0))))
   def skip: P[Syntax] =
     string("skip").as(skipComm)
   def waitc: P[Syntax] =
-    (string("wait")~sps *> linP).map(l => Atomic(Nil,DiffEqs(Nil,For(l))))
+    (string("wait")~sps *> notlinP).map(l => Atomic(Nil,DiffEqs(Nil,For(l))))
   def assign: P[Syntax] = //: P[Assign] =
-    (varName ~ string(":=").surroundedBy(sps) ~ linP)
-      .map(x => Atomic(List(Assign(Var(x._1._1), x._2)),DiffEqs(Nil,For(Value(0)))))
+    (varName ~ string(":=").surroundedBy(sps) ~ notlinP)
+      .map(x => Atomic(List(Assign(VarNotLin(x._1._1), x._2)),DiffEqs(Nil,For(ValueNotLin(0)))))
 
   def diffEqsP: P[Syntax] =
     (diffEqsCoreP ~ sps ~ durP.?)
@@ -248,8 +303,8 @@ object Parser2 {
             char(',').as((x:DiffEqs,y:DiffEqs) => DiffEqs(x.eqs:::y.eqs,Forever)))
 
   def diffEqP: P[DiffEq] =
-    (varName ~ char('\'') ~ char('=').surroundedBy(sps) ~ linP)
-      .map(x => Var(x._1._1._1) ^= x._2)
+    (varName ~ char('\'') ~ char('=').surroundedBy(sps) ~ notlinP) //New
+      .map(x => VarNotLin(x._1._1._1) ^= x._2) //New
 //
 //
 //  ////// auxiliary ////
diff --git a/src/main/scala/hprog/lang/SageParser.scala b/src/main/scala/hprog/lang/SageParser.scala
old mode 100644
new mode 100755
index 7f11e79..b552ce2
--- a/src/main/scala/hprog/lang/SageParser.scala
+++ b/src/main/scala/hprog/lang/SageParser.scala
@@ -23,11 +23,6 @@ object SageParser extends RegexParsers {
     */
   def parseSol(c: String): ParseResult[SySolution] = {
     val res = parseAll(sols, c)
-//    res match {
-//      case Success(result, _) =>
-//        println(s"[ParserS] $c  -->  ${hprog.backend.Show(result)}")
-//      case _ =>
-//    }
     res
   }
 
@@ -39,21 +34,14 @@ object SageParser extends RegexParsers {
     */
   def parseExpr(c: String): ParseResult[SyExprAll] = {
     val res = parseAll(eqExpr, c)
-//    res match {
-//      case Success(result, _) =>
-//        println(s"[Parser] $c  -->  ${hprog.backend.Show.pp(result)}")
-//      case _ =>
-//    }
+
     res
   }
 
-  //  def pexp(c:String): ParseResult[Cond] = parseAll(condP,c)
-
   override def skipWhitespace = true
 
   override val whiteSpace: Regex = "( |\t|\r|\f|\n|//.*)+".r
-//  override val whiteSpace: Regex = "[ \t\r\f\n]+".r
-  val identifier: Parser[String] = """[a-z][a-zA-Z0-9_]*""".r
+  val identifier: Parser[String] = """[a-z_][a-zA-Z0-9_]*""".r
   val identifierCap: Parser[String] = """[a-zA-Z][a-zA-Z0-9_]*""".r
   val nameP: Parser[String] = "[a-zA-Z0-9.-_!$]+".r
   val floatP: Parser[String] = """[a-z][a-zA-Z0-9_]*""".r
@@ -111,14 +99,15 @@ object SageParser extends RegexParsers {
       case None~_~_~e => SFun("exp",List(e))//(t:Double) => (ctx:Valuation) => Math.exp(e(t)(ctx))
       case _~_~_~e => invert(SFun("exp",List(e)))//(t:Double) => (ctx:Valuation) => Math.exp(e(t)(ctx))
     } |
-    lit ~ opt("^"~>lit) ^^ {
-      case e ~ None => e
-      case e1 ~ Some(e2) => SPow(e1,e2)//(t:Double) => (ctx:Valuation) => Math.pow(e1(t)(ctx),e2(t)(ctx))
+    opt("-") ~ lit ~ opt("^"~>lit) ^^ {
+      case None ~ e ~ None => e
+      case Some(_) ~ e ~ None => SSub(SVal(0.0),e)
+      case None ~ e1 ~ Some(e2) => SPow(e1,e2)//(t:Double) => (ctx:Valuation) => Math.pow(e1(t)(ctx),e2(t)(ctx))
+      case Some(_) ~ e1 ~ Some(e2) => SSub(SVal(0.0),SPow(e1,e2))
     }
 
   lazy val lit: Parser[SyExprAll] =
-    function | rational | time | "("~>eqExpr<~")" | negation
-
+    time | function | rational | "("~>eqExpr<~")" //| negation
   lazy val negation: Parser[SyExprAll] =
     "-"~>lit ^^ (e => SSub(SVal(0.0),e)) // (e => (t: Double) => (ctx: Valuation) => -e(t)(ctx))
   def time: Parser[SyExprTime] =
@@ -132,21 +121,16 @@ object SageParser extends RegexParsers {
     """-?[0-9]+(\.([0-9]+))?(e-?([0-9]+))?""".r ^^ { s: String => SVal(s.toDouble) }
 
   lazy val function: Parser[SyExprAll] =
-    identifier~opt("("~>eqExprs<~")") ^^ {
+    identifier~opt("("~> eqExprs <~")") ^^ {
       case name~Some(arg) =>
         SFun(name,arg)
-      case name~_ =>
+      case name ~ None =>
         SVar(name)
-//      case name~_~arg~_ => (t:Double)=>(ctx:Valuation)=> (name,arg(t)(ctx)) match {
-//        case (_,0) if ctx.contains(name) => ctx(name)
-//        case ("sin",v) => Math.sin(v)
-//        case ("cos",v) => Math.cos(v)
-//        case ("sqrt",v) => Math.sqrt(v)
-//        case ("log",v) => Math.log(v)
-//        case ("log10",v) => Math.log10(v)
-//        case (_,v) => throw new ParserException(s"Unknown function '$name($v)'")
-//      }
+    }|
+    identifier ~ "(" ~ ")" ^^ { //new
+      case name ~ _ ~ _ => SFun(name,List())
     }
+
   lazy val eqExprs: Parser[List[SyExprAll]] =
     eqExpr ~ opt(","~>eqExprs) ^^ {
       case e~None => List(e)
@@ -161,6 +145,7 @@ object SageParser extends RegexParsers {
       case SFun(_, _) => SMult(SVal(-1),e)
       case SPow(_, _) => SMult(SVal(-1),e)
       case SDiv(e1, e2)  => SDiv(invert(e1),e2)
+      case SRes(e1, e2)  => SRes(invert(e1),e2)
       case SMult(e1, e2) => SMult(invert(e1),e2)
       case SAdd(e1, e2)  => SAdd(invert(e1),invert(e2))
       case SSub(e1, e2)  => SSub(e2,e1)
diff --git a/src/main/scala/hprog/project/build.properties b/src/main/scala/hprog/project/build.properties
new file mode 100644
index 0000000..46e43a9
--- /dev/null
+++ b/src/main/scala/hprog/project/build.properties
@@ -0,0 +1 @@
+sbt.version=1.8.2
diff --git a/src/main/scala/hprog/testar/parser_syntax_show.scala b/src/main/scala/hprog/testar/parser_syntax_show.scala
new file mode 100755
index 0000000..0c761ed
--- /dev/null
+++ b/src/main/scala/hprog/testar/parser_syntax_show.scala
@@ -0,0 +1,54 @@
+package hprog.testar
+
+import hprog.ast._
+import Syntax._
+
+import hprog.lang.Parser
+import Parser._
+
+
+import hprog.backend.Show
+import Show._
+
+
+
+object parser_syntax_show {
+
+	def testing_parser(s:String):Syntax={ //ParseResult[Syntax]
+       var parser_p=parse(s)
+       return parser_p.get
+
+       /*
+       var parser_p=parse(s).get
+       //var parser_s=(parser_p).toString
+       println("Parsing:"+ parser_p)
+       return parser_p
+
+       //var show_s=apply(parser_s.asInstanceOf[Syntax])
+       //println("Show:"+show_s)
+       */
+	}
+
+/*
+	def testing_show(s:Syntax):String={
+		var show_s=apply(s)
+		println("Showing:"+show_s)
+		return show_s
+	}
+    
+    // serve para verificar se o parsing está bem feito
+	def testing(s:String): Unit={
+		var p1=testing_parser(s)
+		var s1=testing_show(p1)
+		var p2=testing_parser(s1)
+		var s2=testing_show(p2)
+
+		if (s1==s2){
+			println("Sucefull")
+		} else {
+			println("Not Sucefull")
+		}
+	}
+
+*/
+}
diff --git a/src/test/scala/hprog/TestParser.scala b/src/test/scala/hprog/TestParser.scala
old mode 100644
new mode 100755
diff --git a/src/test/scala/hprog/TestSage.scala b/src/test/scala/hprog/TestSage.scala
old mode 100644
new mode 100755
diff --git a/src/test/scala/hprog/TestSageParser.scala b/src/test/scala/hprog/TestSageParser.scala
old mode 100644
new mode 100755
